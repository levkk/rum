{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Getting started","text":"<p>Rust Web Framework (Rwf for short) is a set of libraries and tools to build web applications using the Rust programming language. It aims to be comprehensive by providing all features for you to build modern, fast, and secure web apps out of the box.</p> <p>Rwf has very few dependencies and is easy to install and use within new or existing Rust applications.</p>"},{"location":"#install-rust","title":"Install Rust","text":"<p>If you haven't already, install the Rust compiler and tools from rust-lang.org. Rwf doesn't use any nightly or experimental features, so the stable version of the compiler will work.</p>"},{"location":"#create-a-project","title":"Create a project","text":"<p>Rwf can be used inside any Rust binary or library project. If you don't have a project already, you can create one with Cargo:</p> <pre><code>cargo init --bin rwf-web-app\n</code></pre>"},{"location":"#install-rwf","title":"Install Rwf","text":"<p>Rwf has two packages:</p> <ul> <li><code>rwf</code> which is the Rust crate<sup>1</sup> used to build web apps</li> <li><code>rwf-cli</code> which is a binary application that helps manage Rust projects built with Rwf</li> </ul> <p>To install them, run the following while inside the root directory of your Cargo-created project:</p> <pre><code>cargo add rwf\ncargo install rwf-cli\n</code></pre>"},{"location":"#building-the-app","title":"Building the app","text":"<p>With the packages installed, you're ready to launch your first web app in Rust. Rwf is built using the MVC (Model-view-controller) design pattern, so to get started, let's create a simple controller that will serve the index page (<code>/</code>) of your app:</p> <pre><code>use rwf::prelude::*;\n\n#[derive(Default)]\nstruct Index;\n\n#[async_trait]\nimpl Controller for Index {\n    async fn handle(&amp;self, request: &amp;Request) -&gt; Result&lt;Response, Error&gt; {\n        Ok(Response::new().html(\"&lt;h1&gt;My first Rwf app!&lt;/h1&gt;\"))\n    }\n}\n</code></pre> <p><code>rwf::prelude::*</code> includes the vast majority of types, structs, traits and functions you'll be using when building controllers with Rwf. Adding this declaration to your source files will make handling imports easier, but it's not required.</p> <p>Rwf controllers are defined as Rust structs that implement the <code>Controller</code> trait. The trait is asynchronous, hence the <code>#[async_trait]</code> macro<sup>2</sup>, and has only one method you need to implement: <code>async fn handle</code>. This method accepts a <code>Request</code>, and must return a <code>Response</code>.</p> <p>In this example, we are returning HTTP <code>200 - OK</code> with the body <code>&lt;h1&gt;My first Rwf app&lt;/h1&gt;</code>. This is not strictly valid HTML, but it'll work in all browsers for our demo purposes.</p>"},{"location":"#launching-the-server","title":"Launching the server","text":"<p>Once you have at least one controller, you can add it to the Rwf HTTP server and launch it at the address and port of your choosing:</p> <pre><code>use rwf::http::{self, Server};\n\n#[tokio::main]\nasync fn main() -&gt; Result&lt;(), http::Error&gt; {\n    // Configure then logger (stderr with colors by default)\n    Logger::init();\n\n    Server::new(vec![\n        route!(\"/\" =&gt; Index),\n    ])\n    .launch(\"0.0.0.0:8000\")\n    .await\n}\n</code></pre> <p>Rwf uses the <code>log</code> crate for logging. <code>Logger::init()</code> automatically configures it for your app using <code>tracing-subscriber</code>, but if you prefer, you can configure logging yourself using the crate of your choosing.</p> <p>Launching the server can be done with Cargo:</p> <pre><code>cargo run\n</code></pre> <p>Once the server is running, you can visit the index page by pointing your browser to http://localhost:8000.</p> <p>The full code for this is available on GitHub in examples/quick-start.</p>"},{"location":"#learn-more","title":"Learn more","text":"<ul> <li>Controllers</li> <li>Models</li> <li>Views</li> </ul> <ol> <li> <p>A \"crate\" is a Rust package used as a dependency in other packages. It's analogous to \"package\" in JavaScript or Python.\u00a0\u21a9</p> </li> <li> <p>The Rust language support for async traits is still incomplete. The <code>async_trait</code> crate helps with writing async traits in an ergonomic way.\u00a0\u21a9</p> </li> </ol>"},{"location":"configuration/","title":"Configuration","text":"<p>Rwf supports file-based and environment-based configuration. The list of configurable options are ever growing, and currently supported features are listed below.</p>"},{"location":"configuration/#enabling-configuration","title":"Enabling configuration","text":"<p>To configure Rwf, place a file called <code>rwf.toml</code> into the working directory of your app. During development, this should be the root directory of your Cargo project. At startup, Rwf will automatically load configuration settings from that file, as they are needed by the application.</p>"},{"location":"configuration/#available-settings","title":"Available settings","text":"<p>The configuration file is using the TOML language. If you're not familiar with TOML, it's pretty simple and expressive language commonly used in the world of Rust programming.</p> <p>Rwf configuration file is split into multiple sections. The <code>[general]</code> section controls various options such as logging settings, and which secret key to use for encryption. The <code>[database]</code> section configures database connection settings, like the database URL, connection pool size, and others.</p>"},{"location":"configuration/#general","title":"<code>[general]</code>","text":"Setting Description Default <code>log_queries</code> Toggles logging of all SQL queries executed by the ORM. <code>false</code> <code>secret_key</code> Secret key, encoded using base64, used for encryption. Randomly generated <code>cache_templates</code> Toggle caching of dynamic templates. <code>false</code>"},{"location":"configuration/#secret-key","title":"Secret key","text":"<p>The secret key is a base64-encoded string of randomly generated data. A valid secret key contains 256 bits of entropy and must be generated using a secure random number generator.</p> <p>If you have Python installed on your system, you can generate a secret key for Rwf in just a few lines of code:</p> PythonOutput <pre><code>import base64\nimport secrets\n\nsecret = base64.b64encode(secrets.token_bytes(int(256/8)))\nprint(secret)\n</code></pre> <pre><code>BJ3Og8l/Q8f+fLvQpb9CP7uUu/VG1/+CN2a1f/QyHWY=\n</code></pre> <p>Warning</p> <p>Do not use this example key in production. Always generate a new one and keep it secret.</p>"},{"location":"configuration/#database","title":"<code>[database]</code>","text":"Setting Description Default <code>name</code> Name of the database to connect to. Same as the <code>$USER</code> shell variable. If not set, default is <code>postgres</code>. <code>user</code> Name of the user to connect with to the database. <code>$USER</code>, or <code>postgres</code> if not set. <code>url</code> Fully-qualified database connection string. <code>postgresql://{user}/localhost:5432/{name}</code>, where <code>{user}</code> and <code>{name}</code> are <code>name</code> and <code>user</code> configuration values."},{"location":"configuration/#url","title":"<code>url</code>","text":"<p>The database URL was originally created by The Twelve Factor App and uses the URL format for specifying database connections. It follows a standard format, as follows:</p> <pre><code>driver://user:password@host:port/database_name\n</code></pre> <p>For connecting to PostgreSQL, the <code>driver</code> is <code>postgresql</code> (or <code>postgres</code> is also acceptable).</p>"},{"location":"encryption/","title":"Encryption","text":"<p>Rwf uses AES-128 for encrypting user sessions and private cookies. The same functionality is available through the <code>rwf::crypto</code> module to encrypt and decrypt arbitrary data.</p>"},{"location":"encryption/#encrypt-data","title":"Encrypt data","text":"<p>To encrypt data using AES-128 and the application secret key, you can use the <code>encrypt</code> function, for example:</p> <pre><code>use rwf::crypto::encrypt;\n\nlet data = serde_json::json!({\n    \"user\": \"test\",\n    \"password\": \"hunter2\"\n});\n\n// JSON is converted into a byte array.\nlet data = serde_json::to_vec(&amp;data).unwrap();\n\n// Data is encrypted with AES.\nlet encrypted = encrypt(&amp;data).unwrap();\n</code></pre> <p>Any kind of data can be encrypted, as long as it's serializable to an array of bytes. Serialization can typically be achieved by using <code>serde</code>.</p> <p>Encryption produces a base64-encoded UTF-8 string. You can save this string in the database or send it via an insecure medium like email.</p>"},{"location":"encryption/#decrypt-data","title":"Decrypt data","text":"<p>To decrypt the data, you can call the <code>decrypt</code> function on the string produced by the <code>encrypt</code> function. The decryption algorithm will automatically convert the base64-encoded string to bytes and decrypt those bytes using the secret key, for example:</p> <pre><code>use rwf::crypto::decrypt;\n\nlet decrypted = decrypt(&amp;encrypted).unwrap();\nlet json = serde_json::from_slice(&amp;decrypted).unwrap();\n\nassert_eq!(json[\"user\"], \"test\");\n</code></pre>"},{"location":"logging/","title":"Logging","text":"<p>Rwf uses the <code>log</code> crate for logging. The crate employs the standard <code>INFO</code>, <code>WARN</code>, <code>ERROR</code>, and <code>DEBUG</code> levels to output information of different importance. If you have a logging preference, e.g. you want to use JSON-structured logs without colors, you can use a logging subscriber of your choice. Alternatively, you can use the logger that comes with Rwf, like so:</p> <pre><code>use rwf::prelude::*;\n\n#[tokio::main]\nasync fn main() {\n    // Make sure to call this only once in your application.\n    Logger::init();\n\n    /* ... */\n}\n</code></pre>"},{"location":"logging/#log-queries","title":"Log queries","text":"<p>By default, queries executed against the database are not logged. If you want to see what's being executed (and how long queries are taking to return results), toggle the <code>log_queries</code> setting in the configuration.</p>"},{"location":"logging/#log-requests","title":"Log requests","text":"<p>All HTTP requests to Rwf are logged at the <code>INFO</code> level. This is useful in production to detect application activity and debug any issues (e.g. bad load balancer configuration).</p>"},{"location":"logging/#default-log-level","title":"Default log level","text":"<p>By default, Rwf applications are launched with the <code>INFO</code> log level. Since Rwf <code>Logger</code> is using <code>tracing-subscriber</code>, you can change that by setting the <code>RUST_LOG</code> environment variable, for example:</p> <pre><code>export RUST_LOG=debug\n</code></pre>"},{"location":"background-jobs/","title":"Jobs overview","text":"<p>Background jobs, also known as asynchronous jobs, are code that can run independently of the main HTTP request/response life cycle. Executing code in background jobs allows you to perform useful work without making the client wait for the job to finish. Examples of background jobs are sending emails or talking to third-party APIs.</p> <p>Rwf has its own background job queue and workers that can perform those jobs.</p>"},{"location":"background-jobs/#defining-jobs","title":"Defining jobs","text":"<p>A background job is any Rust struct that implements the <code>Job</code> trait. The only trait method the job needs to implement is the <code>async fn execute</code> method which accepts job arguments encoded with JSON.</p> <p>For example, if we wanted to send a welcome email to all users that sign up for your web app, we can do so as a background job:</p> <pre><code>use rwf::prelude::*;\nuse rwf::job::{Error as JobError};\nuse serde::{Serialize, Deserialize};\n\n#[derive(Default, Debug, Serialize, Deserialize)]\nstruct WelcomeEmail {\n    email: String,\n    user_name: String,\n}\n\n#[async_trait]\nimpl Job for WelcomeEmail {\n    /// Code in this function will be executed in the background.\n    async fn execute(&amp;self, args: serde_json::Value) -&gt; Result&lt;(), JobError&gt; {\n        let args: WelcomeEmail = serde_json::from_value(args)?;\n\n        // Send the email to the user\n        // with the given email address.\n\n        Ok(())\n    }\n}\n</code></pre>"},{"location":"background-jobs/#spawning-workers","title":"Spawning workers","text":"<p>Once we have background jobs, we need to create background workers that will run in separate threads (Tokio tasks, in reality), and execute those jobs as they are sent to the queue. Spawning workers can be done from anywhere in the code, but typically done so from the <code>main</code> function:</p> <pre><code>use rwf::job::Worker;\nuse tokio::time::{sleep, Duration};\n\n#[tokio::main]\nasync fn main() -&gt; Result&lt;(), Error&gt; {\n    // Create a new worker with 4 threads.\n    let worker = Worker::new(vec![\n        WelcomeEmail::default().job()\n    ])\n\n    worker.start().await?;\n\n    //  Put the main task to sleep indefinitely.\n    sleep(Duration::MAX).await;\n}\n</code></pre>"},{"location":"background-jobs/#sharing-processes","title":"Sharing processes","text":"<p>Workers can be spawned inside the app without having to create a separate binary application. Since most jobs will be running async code, Tokio will effectively load balance foreground (HTTP requests/responses) and background workloads.</p> <p>To spawn a worker inside the web app, use the code above without the <code>sleep</code>. The <code>Worker::start</code> method returns almost immediately, since it only spawns a worker on a separate Tokio task.</p>"},{"location":"background-jobs/#scheduling-jobs","title":"Scheduling jobs","text":"<p>With the background jobs defined and the workers running, we can start scheduling jobs to run in the background. A job can be scheduled to run from anywhere in the code by calling the <code>Job::execute_async</code> method:</p> <pre><code>let email = WelcomeEmail {\n    email: \"new-user@example.com\".to_string(),\n    user_name: \"Alice\".to_string(),\n};\n\n// Convert the job to a JSON value.\nlet args = serde_json::to_value(&amp;email)?;\n\n// Schedule the job to run in the background\n// as soon as possible.\nemail.execute_async(args).await?;\n</code></pre> <p>The <code>execute_async</code> method creates a record of the job in the queue and returns immediately without doing the actual work. This makes this method very quick so you can schedule multiple jobs inside a controller without it having noticeable effect on endpoint latency.</p>"},{"location":"background-jobs/cron/","title":"Cron jobs","text":"<p>Cron jobs, or scheduled jobs, are background jobs that are performed automatically based on a schedule. For example, if you want to send a newsletter to your users every week, you can create a background job and schedule it to run weekly using the built-in cron.</p>"},{"location":"background-jobs/cron/#defining-scheduled-jobs","title":"Defining scheduled jobs","text":"<p>A scheduled job is a regular background job, for example:</p> <pre><code>use rwf::prelude::*;\nuse rwf::job::{Error as JobError};\n\n#[derive(Default, Debug, Serialize, Deserialize)]\nstruct WeeklyNewsletter;\n\n#[async_trait]\nimpl Job for WeeklyNewsletter {\n    /// Code in this function will be executed in\n    /// the background.\n    async fn execute(&amp;self, _args: serde_json::Value) -&gt; Result&lt;(), JobError&gt; {\n        // Send the newsletter to all users.\n        Ok(())\n    }\n}\n</code></pre> <p>To run a job on a schedule, you need to add it in two places:</p> <ul> <li>The list of jobs the worker can run</li> <li>The crontab (or the clock, as we call it)</li> </ul> <pre><code>// Crontab\nlet schedule = vec![\n    WeeklyNewsletter::default()\n        .schedule(\n            serde_json::Value::Null,\n            \"0 0 * * 0\",\n        ), // Every Sunday at midnight\n];\n\n// Background jobs\nlet jobs = vec![\n    WeeklyNewsletter::default().job()\n];\n\nlet worker = Worker::new(jobs)\n    .clock(schedule);\n\nworker.start().await?;\n</code></pre>"},{"location":"background-jobs/queue-guarantees/","title":"Job queue guarantees","text":"<p>The background queue is stored in the database, so jobs will not get lost. Workers will attempt to run a job at least once. Even if workers crash, when they are restarted, any running jobs will be rescheduled.</p> <p>Because of this guarantee, jobs should strive to be idempotent: the same job can be executed multiple times.</p>"},{"location":"background-jobs/queue-guarantees/#performance","title":"Performance","text":"<p>The job queue is using PostgreSQL's <code>FOR UPDATE SKIP LOCKED</code> mechanism, which has been shown to support high concurrency job queues.</p>"},{"location":"background-jobs/queue-guarantees/#polling","title":"Polling","text":"<p>Workers poll the queue every second. If there are no jobs, the worker goes to sleep and polls again in one second. If a job is available, it will be executed immediately. Once the job completes, the worker will attempt to fetch the next job immediately, restarting this cycle.</p>"},{"location":"background-jobs/queue-guarantees/#concurrency","title":"Concurrency","text":"<p>By default, a worker executes one job at a time. This allows to control for background concurrency easily, without complex throttling mechanisms. If you want to execute many jobs concurrently, you can spawn as many workers as you wish. Each worker will poll the queue for jobs once a second.</p> <p>To spawn more workers, call <code>Worker::spawn</code> as many times as you wish to have workers, for example:</p> <pre><code>let worker = Worker::new(vec![])\n  .start()\n  .await?\n  .spawn()\n  .spawn()\n  .spawn();\n</code></pre> <p>The above code will spawn 4 workers in total.</p>"},{"location":"controllers/","title":"Controller basics","text":"<p>Rwf comes with multiple pre-built controllers that can be used out of the box, for example, to handle WebSocket connections, REST-style interactions, or serving static files. For everything else, the <code>Controller</code> trait can be implemented to handle any kind of HTTP requests.</p>"},{"location":"controllers/#whats-a-controller","title":"What's a controller?","text":"<p>The controller is the C in MVC: it handles user interactions with the web app and performs actions on their behalf. A controller takes care of user inputs, like forms, and all other HTTP requests to the app.</p>"},{"location":"controllers/#writing-a-controller","title":"Writing a controller","text":"<p>A controller is a plain Rust struct that implements the <code>Controller</code> trait. As an example, let's write a controller that returns the current time in UTC.</p>"},{"location":"controllers/#import-types","title":"Import types","text":"<pre><code>use rwf::prelude::*;\n</code></pre> <p>The prelude module contains most of the types and traits necessary to work with Rwf. Including it will save you time and effort when writing code, but it's not required.</p>"},{"location":"controllers/#define-the-struct","title":"Define the struct","text":"<pre><code>#[derive(Default)]\nstruct CurrentTime;\n</code></pre> <p>This struct has no fields, but you can add any internal state you want to keep track of in there. The <code>Default</code> trait is derived automatically to provide a convenient way to instantiate it.</p>"},{"location":"controllers/#implement-the-controller-trait","title":"Implement the <code>Controller</code> trait","text":"<pre><code>#[async_trait]\nimpl Controller for CurrentTime {\n    /// This function handles incoming HTTP requests.\n    async fn handle(&amp;self, request: &amp;Request) -&gt; Result&lt;Response, Error&gt; {\n        let time = OffsetDateTime::now_utc();\n\n        // This creates an HTTP \"200 OK\" response,\n        // with \"Content-Type: text/plain\" header.\n        let response = Response::new()\n            .text(format!(\"The current time is: {:?}\", time));\n\n        Ok(response)\n    }\n}\n</code></pre> <p>The <code>Controller</code> trait is asynchronous. Support for async traits in Rust is still incomplete, so we use the <code>async_trait</code> library to make it easy to use. The trait itself has a few methods, most of which have reasonable defaults. The only method that needs to be written by hand is <code>async fn handle()</code>.</p>"},{"location":"controllers/#handle","title":"<code>handle</code>","text":"<p>The <code>handle</code> method accepts a <code>Request</code> and must return a <code>Response</code>. The response can be any valid HTTP response, including <code>404</code> or even <code>500</code>.</p>"},{"location":"controllers/#errors","title":"Errors","text":"<p>If an error occurs inside the <code>async fn handle</code> function, Rwf will return HTTP <code>500</code> automatically and display the error to the client.</p>"},{"location":"controllers/#connecting-controllers","title":"Connecting controllers","text":"<p>Once you implement a controller, adding it to the app requires mapping it to a route. A route is a unique URL, starting at the root of the app. For example, <code>/signup</code> is a route that could map to the <code>Signup</code> controller, and allow your users to create accounts.</p> <p>Adding controllers to the app happens at server startup. A server can be launched from an async task anywhere in the code, but typically is done so from the <code>main</code> function:</p> <pre><code>use rwf::prelude::*;\nuse rwf::http::{self, Server};\n\n#[tokio::main]\nasync fn main() -&gt; Result&lt;(), http::Error&gt; {\n    Server::new(vec![\n        // Map the `/time` route to the `CurrentTime` controller.\n        route!(\"/time\" =&gt; CurrentTime),\n    ])\n    .launch(\"0.0.0.0:8000\")\n    .await\n}\n</code></pre> <p>Note</p> <p>The <code>route!</code> macro is a shorthand for calling <code>CurrentTime::default().route(\"/time\")</code>. We use it because it looks cool, but it's not required. You can instantiate your controller struct in any way you need, and call the <code>Controller::route</code> method when adding it to the server. Alternatively, you can implement the <code>Default</code> trait like we did in this example and use the macro.</p>"},{"location":"controllers/#test-with-curl","title":"Test with cURL","text":"<p>Once the server is up and running, you can test your endpoints with cURL (or with a regular browser, like Firefox):</p> cURLOutput <pre><code>curl localhost:8000/time -w '\\n'\n</code></pre> <pre><code>The current time is: 2024-10-17 0:23:34.6191103 +00:00:00\n</code></pre>"},{"location":"controllers/#learn-more","title":"Learn more","text":"<p>Read more about working with controllers, requests, and responses:</p> <ul> <li>Requests</li> <li>Responses</li> </ul>"},{"location":"controllers/authentication/","title":"Authentication","text":"<p>Rwf has multiple authentication and authorization mechanisms. Different kinds of authentication require their own kinds of user-supplied credentials. The most commonly used mechanism is Session authentication, which has built-in methods for easy use in controllers.</p>"},{"location":"controllers/authentication/#session-authentication","title":"Session authentication","text":"<p>Session authentication checks that the user-supplied session cookie is valid (not expired). If that's not the case, the request is either rejected with a <code>403 - Forbidden</code> or provided an endpoint to re-authenticate, e.g., using a username and password, with a <code>302 - Found</code> redirect.</p>"},{"location":"controllers/authentication/#enable-session-authentication","title":"Enable session authentication","text":"<p>To enable session authentication, it needs to be configured on the controller by implementing the <code>auth</code> method:</p> <pre><code>use rwf::prelude::*;\n\n/// A controller that requires authentication.\nstruct Private {\n    auth: AuthHandler,\n}\n\nimpl Default for Private {\n    fn default() -&gt; Self {\n        Private {\n            // Redirect unauthenitcated requests to the `/login` route.\n            auth: AuthHandler::new(\n                SessionAuth::redirect(\"/login\"),\n            ),\n        }\n    }\n}\n\n#[async_trait]\nimpl Controller for Private {\n    /// Enable authentication on this controller.\n    fn auth(&amp;self) -&gt; &amp;AuthHandler {\n        &amp;self.auth\n    }\n\n    /* ... */\n}\n</code></pre>"},{"location":"controllers/authentication/#basic-authentication","title":"Basic authentication","text":"<p>HTTP Basic is a form of authentication using a global username and password. It's not particularly secure, but it's good enough to protect an endpoint quickly against random visitors. Enabling basic authentication is as simple as setting an <code>AuthHandler</code> with <code>BasicAuth</code> on your controller. See examples/auth for examples on how to do this.</p>"},{"location":"controllers/cookies/","title":"Cookies","text":"<p>HTTP cookies are a special header that contains key/value-encoded information. Cookies are typically set on the server, and the client (like a browser) should store them on their end and send them with each subsequent request to the server.</p> <p>Cookies allow persisting information between what are otherwise stateless HTTP requests.</p>"},{"location":"controllers/cookies/#read-cookies","title":"Read cookies","text":"<p>Cookies sent by the browser can be read inside a controller by calling the <code>cookies</code> method:</p> <pre><code>let cookies = request.cookies();\n</code></pre> <p>Since cookies are encoded as key/value pairs, fetching a cookie value can be done by knowing its name:</p> <pre><code>let session_id = cookies.get(\"session_id\");\n\nif let Some(session_id) = session_id {\n    println!(\"session_id: {}\", session_id.value());\n}\n</code></pre> <p>More often than not, cookies are used to store plain text information, so no special decoding procedure is required to read the cookie value.</p>"},{"location":"controllers/cookies/#set-cookies","title":"Set cookies","text":"<p>Setting cookies on the server can be done when crafting a response:</p> <pre><code>use rwf::prelude::*;\n\nlet mut response = Response::new();\n\nlet cookie = CookieBuilder::new()\n    .name(\"session_id\")\n    .value(\"1234\")\n    .max_age(Duration::days(1))\n    .build();\n\nresponse\n    .cookies()\n    .add(cookie);\n</code></pre> <p>This produces a <code>Set-Cookie</code> header encoded with the cookie name, value, and other attributes like <code>MaxAge</code>. You can learn more about cookie attributes and their meaning on MDN.</p>"},{"location":"controllers/cookies/#private-cookies","title":"Private cookies","text":"<p>Private cookies are cookies that have been encrypted, so the client can't see their contents, or modify them, without the server detecting (and automatically rejecting) them. They are useful for storing sensitive information like a user's session, which can be used in later requests to authenticate requests.</p>"},{"location":"controllers/cookies/#set-private-cookies","title":"Set private cookies","text":"<p>Setting private cookies on the response works much like regular cookies, except instead of using <code>add</code>, you need to use <code>add_private</code>:</p> <pre><code>response\n    .cookies()\n    .add_private(cookie)?;\n</code></pre> <p>Cookies are encrypted with AES-128, using the security key set in the configuration.</p>"},{"location":"controllers/cookies/#read-private-cookies","title":"Read private cookies","text":"<p>Reading private cookies works much like regular cookies, except instead of using <code>get</code>, you need to use <code>get_private</code>:</p> <pre><code>let session_id = cookies.get_private(\"session_id\")?;\n</code></pre> <p>Decryption will be done automatically, and the controller will be able to access the plain text value of the cookie.</p>"},{"location":"controllers/middleware/","title":"Middleware","text":"<p>Middleware runs before a request reaches a controller and has the ability to modify the request, or block it from reaching the controller entirely. Middleware is used to validate incoming requests against some conditions, e.g. required headers. It can also be used to mark requests with special tags, by adding custom headers.</p>"},{"location":"controllers/middleware/#using-middleware","title":"Using middleware","text":"<p>Middleware needs to be specified on each controller. By default, all controllers come with no middleware, so requests processed by them are unmodified from their original state.</p>"},{"location":"controllers/middleware/#define-middleware","title":"Define middleware","text":"<p>Middleware, similar to controllers, is any struct which implements the <code>Middleware</code> trait. The only method that needs implementation is the <code>async fn handle_request</code> method, which accepts a <code>Request</code> and must return an <code>Outcome</code>.</p> <p>If the request is allowed to proceed, <code>Outcome::Forward</code> is returned, containing the request, in its modified or unchanged form. If on the other hand, the request failed some kind of validation, <code>Outcome::Stop</code> must be returned with a <code>Response</code>, for example:</p> <pre><code>use rwf::controller::middleware::prelude::*;\n\nstruct RequiredHeaders {\n    headers: Vec&lt;String&gt;,\n}\n\nimpl Default for RequiredHeaders {\n    fn default() -&gt; Self {\n        Self {\n            headers: vec![\n                \"X-Request-Id\".to_string()\n            ],\n        }\n    }\n}\n\n#[async_trait]\nimpl Middleware for RequiredHeaders {\n    async fn handle_request(&amp;self, request: Request) -&gt; Result&lt;Outcome, Error&gt; {\n        for header in &amp;self.headers {\n            let header = request.headers().get(header);\n\n            if header.is_none() {\n                return Ok(Outcome::Stop(Response::bad_request()));\n            }\n        }\n\n        Ok(Outcome::Forward(request))\n    }\n}\n</code></pre>"},{"location":"controllers/middleware/#enable-middleware","title":"Enable middleware","text":"<p>Enabling middleware needs to be done at the controller level. For each controller where you want the middleware to run, add it to the struct fields and instantiate it when the controller is created:</p> <pre><code>struct Index {\n    middleware: MiddlewareSet,\n}\n\nimpl Default for Index {\n    fn default() -&gt; Self {\n        Index {\n            middleware: MiddlewareSet::new(vec![\n                RequiredHeaders::default()\n                    .middleware(),\n            ])\n        }\n    }\n}\n</code></pre> <p>When implementing the <code>Controller</code> trait for your controller, implement the <code>middleware</code> method as well:</p> <pre><code>#[async_trait]\nimpl Controller for Index {\n    // This controller has middleware.\n    fn middleware(&amp;self) -&gt; &amp;MiddlewareSet {\n        &amp;self.middleware\n    }\n\n    // Middleware will run before this method.\n    async fn handle(&amp;self, request: &amp;Request) -&gt; Result&lt;Response, Error&gt; {\n        /* ... */\n    }\n}\n</code></pre> <p>Adding a controller with middleware to the server requires no special code, since middleware is handled by the <code>Controller</code> trait internally.</p>"},{"location":"controllers/request/","title":"Requests","text":"<p>For each HTTP request served by Rwf, a new <code>Request</code> struct is created. It contains the client IP address, browser headers, cookies, session information, and the request body.</p>"},{"location":"controllers/request/#headers","title":"Headers","text":"<p>Fetching headers sent by the client in the HTTP request can be done by calling the <code>headers</code> method on the request object inside a controller:</p> <pre><code>struct Index;\n\nimpl Controller for Index {\n    // Handle HTTP request.\n    async fn handle(&amp;self, request: &amp;Request) -&gt; Result&lt;Response, Error&gt; {\n        // Get the `Accept` header from the request.\n        let accept = request\n            .headers()\n            .get(\"accept\");\n\n        if let Some(accept) = accept {\n            Ok(Response::new().text(format!(\"Accept: {}\", accept)));\n        } else {\n            Ok(Response::bad_request())\n        }\n    }\n}\n</code></pre> <p>Note</p> <p>Headers in Rwf are case-insensitive, so <code>accept</code> and <code>Accept</code> are equivalent.</p> <p>Most browsers send required headers like <code>Origin</code>, <code>Accept</code>, and <code>User-Agent</code>, but that doesn't mean all HTTP clients will. Checking for valid headers is good practice to avoid bad actors like bots. Read more about intercepting HTTP requests with Middleware.</p>"},{"location":"controllers/request/#request-body","title":"Request body","text":"<p>For requests that include a body, like <code>POST</code> or <code>PUT</code>, the body can be read using multiple methods, depending on the expected content type.</p>"},{"location":"controllers/request/#forms","title":"Forms","text":"<p>HTTP forms submitted using <code>POST</code> (or <code>PUT</code>/<code>PATCH</code>) are encoded using either URL encoding or chunked encoding. Parsing the form data is automatically handled by Rwf, so accessing a form field can be done in a couple ways.</p>"},{"location":"controllers/request/#form-fields","title":"Form fields","text":"<pre><code>let form = request.form_data();\nlet email = form.get::&lt;String&gt;(\"email\");\n\nif let Some(email) = email {\n    // Create account.\n}\n</code></pre> <p>Form fields are converted to a Rust type manually, by passing in the data type to the generic <code>FormData::get</code> function. All data types that implement the <code>FromStr</code> trait are supported, including integers, floats, boolean, and UUIDs.</p>"},{"location":"controllers/request/#strictly-typed-forms","title":"Strictly-typed forms","text":"<p>Instead of parsing form fields manually on each request, you can define a Rust struct with the matching column names and data types to your form:</p> RustHTML <pre><code>#[derive(Debug, macros::Form)]\nstruct UserForm {\n    // required\n    email: String,\n    // required\n    password: String,\n    // optional\n    password2: Option&lt;String&gt;,\n}\n\nlet form = request.form::&lt;UserForm&gt;()?;\n\nif form.password2.is_none() {\n  return Ok(Response::bad_request());\n}\n</code></pre> <pre><code>&lt;form&gt;\n  &lt;input name=\"email\" type=\"text\" required&gt;\n  &lt;input name=\"password\" type=\"password\" required&gt;\n  &lt;input name=\"password2\" type=\"password\"&gt;\n&lt;/form&gt;\n</code></pre>"},{"location":"controllers/request/#json","title":"JSON","text":"<p>If the body is expected to be JSON, it can be read using the <code>json</code> method instead. The <code>json</code> method is generic and automatically converts the request body into a Rust struct using the <code>serde_json</code> crate:</p> RustJSON <pre><code>use serde::Deserialize;\n\n#[derive(Deserialize)]\nstruct User {\n    email: String,\n}\n\nlet user = request.json::&lt;User&gt;()?;\n</code></pre> <pre><code>{\n  \"email\": \"new-user@example.com\"\n}\n</code></pre>"},{"location":"controllers/request/#unstructured-json","title":"Unstructured JSON","text":"<p>If you don't know the schema of the JSON request, you can use <code>json_raw</code> instead, for example:</p> RustJSON <pre><code>let json = request.json_raw()?;\nprintln!(\"{}\", json[\"id\"]);\n</code></pre> <pre><code>{\n  \"id\": 5,\n  \"name\": \"New user\"\n}\n</code></pre>"},{"location":"controllers/request/#parsing-errors","title":"Parsing errors","text":"<p>If you use <code>FormData::get_required</code> or <code>Request::json</code> methods with the <code>?</code> operator, an error will be returned to the client automatically if the parsing of the form data fails. Unlike other controller errors that return HTTP <code>500</code>, this type of error will return HTTP <code>400</code> (Bad Request).</p>"},{"location":"controllers/response/","title":"Responses","text":"<p>Each HTTP request served by Rwf is expected to return a response. If your app is using a REST API, responses are typically JSON. If you prefer HTML over the wire or plain old websites, the responses will contain HTML or text.</p>"},{"location":"controllers/response/#creating-responses","title":"Creating responses","text":"<p>To create a response, you can just instantiate the <code>Response</code> struct and populate the body with the right content. The most popular response types have their own instantiation methods in Rwf:</p> HTMLJSONPlain text <pre><code>let response = Response::new()\n  .html(\"&lt;h1&gt;Big letters!&lt;/h1&gt;\");\n</code></pre> <pre><code>let json = serde_json::json!({\n  \"id\": 5,\n  \"email\": \"test@example.com\"\n});\n\nlet response = Response::new().json(json)?;\n</code></pre> <pre><code>let response = Response::new()\n  .text(\"One apple a day keeps the doctor away!\");\n</code></pre> <p>Using one of those methods will automatically set the right <code>Content-Type</code> and <code>Content-Length</code> headers.</p>"},{"location":"controllers/response/#raw-data","title":"Raw data","text":"<p>If your endpoint is sending binary data or some data type we don't have a method for, you can always set the body and content type manually:</p> <pre><code>let mystery_bytes: Vec&lt;u8&gt; = vec![1, 1, 2, 3, 5, 8, 13];\n\nlet response = Response::new()\n  .header(\"Content-Type\", \"application/octet-stream\")\n  .body(mystery_bytes);\n</code></pre> <p>The <code>Content-Length</code> header is always set automatically, but if you absolutely need to, you can set it manually using the <code>header</code> method.</p>"},{"location":"controllers/response/#headers","title":"Headers","text":"<p>Setting custom headers can be done with the <code>header</code> method:</p> <pre><code>let response = Response::new()\n  .header(\"X-My-Header\", \"My value\")\n  .header(\"Cache\", \"no-store\");\n</code></pre>"},{"location":"controllers/response/#learn-more","title":"Learn more","text":"<ul> <li>Cookies</li> <li>Sessions</li> </ul>"},{"location":"controllers/sessions/","title":"Sessions","text":"<p>A session is an encrypted cookie managed by Rwf. It contains a unique identifier for each browser using your web app. All standard-compliant browsers talking to Rwf-powered apps will have a Rwf session set, and should send it back on each request.</p>"},{"location":"controllers/sessions/#check-for-valid-session","title":"Check for valid session","text":"<p>All controllers can check for the presence of a valid session:</p> <pre><code>let session = request.session();\n\nlet valid = session\n    .map(|session| !session.expired())\n    .unwrap_or(false);\n</code></pre> <p>Unless the session cookie is set and has been encrypted using the correct algorithm and secret key, calling <code>session</code> will return <code>None</code>.</p>"},{"location":"controllers/sessions/#expired-sessions","title":"Expired sessions","text":"<p>If the session is expired, it's advisable not to trust its point of origin. While the contents are guaranteed to be accurate, the browser sending the data has not been validated in several weeks (4 weeks, by default).</p> <p>The session can be used to privately store custom user-specific data. This allows your web apps to persist sensitive data on the client without using <code>localStorage</code> and JavaScript encryption.</p>"},{"location":"controllers/sessions/#session-authentication","title":"Session authentication","text":"<p>Rwf can ensure all requests have valid and current (not expired) sessions. To enable this feature, enable the <code>SessionAuth</code> authentication on your controllers.</p>"},{"location":"controllers/sessions/#store-data-in-session","title":"Store data in session","text":"<p>Rwf sessions allow you to store arbitrary JSON-encoded data. Since browsers place limits on cookie sizes, this data should be relatively small. To store some data in the session, you can set it on the response:</p> <pre><code>let session = Session::new(\n    serde_json::json!({\n        \"data\": \"secret_value\"\n    })\n);\n\nlet response = Response::new()\n  .set_session(session);\n</code></pre>"},{"location":"controllers/sessions/#renew-sessions","title":"Renew sessions","text":"<p>Sessions are automatically renewed on each request. This allows your active users to remain \"logged in\", while inactive ones would be redirected to a login page if session authentication is enabled.</p> <p>Expired sessions are not renewed, so a user holding an expired session will need to use an authentication controller to get a new valid session.</p>"},{"location":"controllers/static-files/","title":"Static files","text":"<p>Rwf comes with a static files server built-in. It will handle serving files out of any directory and will automatically return the right <code>Content-Type</code> header (also known as MIME), based on the file extension.</p>"},{"location":"controllers/static-files/#serve-static-files","title":"Serve static files","text":"<p>The static files server is just another controller, implemented internally. To add it to your app, you can add it to the server at startup:</p> <pre><code>use rwf::controller::StaticFiles;\nuse rwf::http::{Server, self};\n\n#[tokio::main]\nasync fn main() -&gt; Result&lt;(), http::Error&gt; {\n    let server = Server::new(vec![\n        StaticFiles::serve(\"static\")?,\n    ])\n    .launch(\"0.0.0.0:8000\")\n    .await\n}\n</code></pre> <p>This example will serve all static files in the <code>static</code> directory under the <code>/static</code> route.</p>"},{"location":"controllers/websockets/","title":"WebSockets","text":"<p>Rwf comes with built-in WebSockets support, requiring no additional dependencies or configuration.</p>"},{"location":"controllers/websockets/#what-are-websockets","title":"What are WebSockets?","text":"<p>A WebSocket is a bidirectional communication protocol that allows browsers and servers to talk to each other. Unlike normal HTTP responses, which are only delivered when the client asks for them, WebSocket messages can be sent by the server at any time.</p> <p>This is useful for updating web apps in real-time, or sending push notifications when something important happens on the server, for example.</p>"},{"location":"controllers/websockets/#how-do-websockets-work","title":"How do WebSockets work?","text":"<p>A WebSocket connection is a TCP connection. It's established by sending a regular HTTP request with a special header. If the server supports WebSockets, like Rwf does, it responds with a special response and upgrades the connection to use the WebSocket protocol instead of HTTP.</p> <p>WebSockets allow both clients and servers to send text and binary data, both of which are supported.</p>"},{"location":"controllers/websockets/#writing-a-websocket-controller","title":"Writing a WebSocket controller","text":"<p>A WebSocket controller is any Rust struct that implements the <code>WebsocketController</code> trait.</p> <p>The trait has two methods of interest: the first handles new WebSocket connections, and the other incoming messages from the client.</p> <pre><code>use rwf::controller::Websocket;\nuse rwf::prelude::*;\n\n#[derive(Default, macros::WebsocketController)]\nstruct Echo;\n\n#[async_trait]\nimpl WebsocketController for Echo {\n    /// Run some code when a new client connects to the WebScoket server.\n    async fn handle_connection(\n        &amp;self,\n        client: &amp;SessionId,\n    ) -&gt; Result&lt;(), Error&gt; {\n        log::info!(\"Client {:?} connected to the echo server\", client);\n\n        Ok(())\n    }\n\n    /// Run some code when a client sends a message to the server.\n    async fn handle_message(\n        &amp;self,\n        client: &amp;SessionId,\n        message: Message,\n    ) -&gt; Result&lt;(), Error&gt; {\n        // Get an app-wide WebSocket channel to the client.\n        // This will send a message to the client via WebScoket\n        // connection from anywhere in the code.\n        let comms = Comms::websocket(client);\n\n        // Send the message back to the client (we're an echo server).\n        comms.send(message)?;\n\n        Ok(())\n    }\n}\n</code></pre> <p>There are a few things to unpack here. The <code>handle_message</code> method is called every time a client sends a message addressed to this WebSocket controller. What to do with the message depends on the application, but if we were writing a real-time chat app, we would save it to the database and notify all interested clients of a new message.</p> <p>The <code>Comms</code> struct is a global data structure that keeps track of who is connected to our server. You can use it to send a <code>Message</code> to any client at any time.</p> <p>Note</p> <p>The <code>macros::WebsocketController</code> automatically implements the <code>Controller</code> trait. All Rwf controllers have to implement the <code>Controller</code> trait, and the <code>WebsocketController</code> is no exception. The trait automatically implements the <code>handle</code> method, however due to the nature of Rust dynamic dispatch, the <code>handle</code> method of the supertrait has to be called explicitly in the base trait.</p> <p>If you were not to use the macro, you could do the same thing manually:</p> <pre><code>#[async_trait]\nimpl Controller for Echo {\n    async fn handle(&amp;self, request: &amp;Request) -&gt; Result&lt;Response, Error&gt; {\n        WebsocketController::handle(self, request).await\n    }\n}\n</code></pre>"},{"location":"controllers/websockets/#sending-messages-to-clients","title":"Sending messages to clients","text":"<p>All WebSocket clients have a unique session identifier. Sending a message to a client only requires that you know their session ID, which you can obtain from the <code>Request</code>, for example:</p> <pre><code>if let Some(session_id) = request.session_id() {\n    let client = Comms::websocket(&amp;session_id);\n\n    let message = Message::Text(\"hey there\".to_string());\n    client.send(message)?;\n}\n</code></pre> <p>WebSocket messages can be delivered to any client from anywhere in the application, including controllers and background jobs.</p>"},{"location":"controllers/websockets/#starting-a-websocket-server","title":"Starting a WebSocket server","text":"<p>Since WebSockets are built into Rwf, you can just add the controller to the server at startup:</p> <pre><code>use rwf::prelude::*;\nuse rwf::http::{Server, self};\n\n#[tokio::main]\nasync fn main() -&gt; Result&lt;(), http::Error&gt; {\n    let server = Server::new(vec![\n        route!(\"/websocket\" =&gt; Echo),\n    ])\n    .launch(\"0.0.0.0:8000\")\n    .await\n}\n</code></pre>"},{"location":"controllers/websockets/#testing-the-connection","title":"Testing the connection","text":"<p>In a browser of your choice, open up the developer tools console and connect to the WebSocket server:</p> <pre><code>const ws = new WebSocket(\"ws://localhost:8000/websocket\");\n</code></pre> <p>If everything works, you should see a log line in the terminal where the server is running, indicating a new client has joined the party.</p>"},{"location":"controllers/REST/","title":"REST overview","text":""},{"location":"models/","title":"ORM basics","text":""},{"location":"models/#introduction","title":"Introduction","text":"<p>Rwf comes with its own ORM (object-relational mapping). The Rwf ORM is very flexible, supporting anything from basic fetch by primary key queries, to multi-table joins and complex custom queries.</p>"},{"location":"models/#whats-an-orm","title":"What's an ORM?","text":"<p>The ORM is the M in MVC design: the model. It allows to easily retrieve data stored in your database tables and display it in the application, without having to write complex SQL queries by hand.</p> <p>It works by attaching itself to Rust structs and mapping data from table columns to struct fields (and vice versa), converting them from database types to Rust data types automatically in the process.</p>"},{"location":"models/#getting-started","title":"Getting started","text":"<p>Using the ORM is simple and only requires defining a struct for each model (or database table). For example, most web apps will have a <code>User</code> model, which stores its data in a <code>\"users\"</code> table:</p> Column Database data type Rust data type <code>id</code> <code>BIGINT</code> <code>i64</code> <code>email</code> <code>VARCHAR</code> <code>String</code> <code>created_at</code> <code>TIMESTAMPTZ</code> <code>time::OffsetDateTime</code> <p>Defining the Rust struct for the model can be done as follows:</p> <pre><code>use rwf::prelude::*;\n\n#[derive(Clone, macros::Model)]\nstruct User {\n    id: Option&lt;i64&gt;,\n    email: String,\n    created_at: OffsetDateTime,\n}\n</code></pre> <p>The same table in the database can be created with this query<sup>1</sup>:</p> <pre><code>CREATE TABLE users (\n  id BIGSERIAL PRIMARY KEY,\n  email VARCHAR NOT NULL,\n  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()\n);\n</code></pre> <p>Note</p> <p>The <code>id</code> column is using an optional Rust <code>i64</code> integer. This is because the struct will be used for both inserting and selecting data from the table. When inserting, the <code>id</code> column should be <code>None</code> and will be automatically assigned by the database. This ensures that all rows in your tables have a unique primary key.</p>"},{"location":"models/#naming-conventions","title":"Naming conventions","text":"<p>The struct fields have the same name as the database columns, and the data types match their respective Rust types. The table name in the database corresponds to the name of the struct, lowercase and pluralized. For example, <code>User</code> model will refer to the <code>\"users\"</code> table in the database.</p> <p>A row in a database table which contains model data is called a record. The <code>macros::Model</code> macro automatically implements the database to Rust and vice versa types conversion and maps the column values to the struct fields.</p>"},{"location":"models/#query-data","title":"Query data","text":"<p>With the model defined in Rust, writing SQL queries is automatically implemented by the ORM. For example, to fetch a record by primary key, you can do the following:</p> <pre><code>let user = User::find(15)\n    .fetch(&amp;mut conn)\n    .await?;\n</code></pre> <p>The <code>find</code> method is implemented by the <code>Model</code> trait for the <code>User</code> struct automatically. It accepts a Rust integer and produces the following query:</p> <pre><code>SELECT * FROM \"users\" WHERE id = $1\n</code></pre> <p>The <code>fetch</code> method assembles the query, sends it to the database, and returns one row. The row is converted to an instance of the <code>User</code> struct:</p> <pre><code>println!(\"user email: {}\", user.email);\n</code></pre>"},{"location":"models/#fetch-multiple-rows","title":"Fetch multiple rows","text":"<p>Querying multiple rows can be done by using <code>fetch_all</code> instead of <code>fetch</code>, for example:</p> <pre><code>let users = User::all()\n    .order(\"id\")\n    .limit(25)\n    .fetch_all(&amp;mut conn)\n    .await?;\n</code></pre> <p>This will fetch 25 user records from the <code>\"users\"</code> table, ordering them by the primary key. The result will be a <code>Vec&lt;User&gt;</code>, in the order returned by the database:</p> <pre><code>for user in &amp;users {\n    println!(\"{}: {}\", user.id, user.email);\n}\n</code></pre> <p>The ORM can be used to write easy and complex queries alike, without having to learn SQL. Rwf currently supports PostgreSQL, but other databases like SQLite and MySQL are on the roadmap.</p> <ol> <li> <p>See migrations to learn how to create tables in your database reliably.\u00a0\u21a9</p> </li> </ol>"},{"location":"models/connection-pool/","title":"Connection pool","text":"<p>Rwf manages database connections automatically. Since Rwf apps are multi-threaded and asynchronous, a typical deployment will require multiple connections to the database to support concurrent requests. The connection pool takes care of creating and closing connections, and providing them to to the app as needed.</p>"},{"location":"models/connection-pool/#get-a-connection","title":"Get a connection","text":"<p>To execute queries with the ORM, you'll need to check out a connection from the pool. You can do so as follows from anywhere in the code:</p> <pre><code>let mut conn = Pool::connection().await?;\n</code></pre> <p>Once you have a connection, you can pass it to the ORM each time you need to execute a query:</p> <pre><code>let users = User::all()\n    .fetch_all(&amp;mut conn)\n    .await?;\n</code></pre>"},{"location":"models/connection-pool/#return-connection-to-the-pool","title":"Return connection to the pool","text":"<p>Returning the connection to the pool is done automatically when the <code>conn</code> variable goes out of scope. In Rust semantics, the <code>conn</code> variable is \"dropped\". For example, to checkout a connection for only one query, you can do so inside its own scope:</p> <pre><code>async fn get_users() -&gt; Result&lt;Vec&lt;User&gt;, Error&gt; {\n    let mut conn = Pool::connection().await?;\n    let users = User::all()\n        .fetch_all(&amp;mut conn)\n        .await?;\n    Ok(users)\n    // The connection is returned to the pool here.\n}\n</code></pre>"},{"location":"models/connection-pool/#transactions","title":"Transactions","text":"<p>All queries are executed inside implicit transactions. If you need to execute multiple queries inside a single transaction, you need to start one explicitly:</p> <pre><code>let mut transaction = Pool::transaction().await?;\n</code></pre> <p>The transaction follows the same scope semantics as a pool connection. When it goes out scope, the transaction is automatically rolled back and the connection is returned back to the pool. If you want to commit any changes you made inside the transaction, you need to call <code>commit</code> explicitly:</p> <pre><code>transaction.commit().await?;\n</code></pre> <p>Automatic rollbacks are a safety feature of Rwf connection management. In case an error happens in Rust mid-transaction, the changes are automatically reverted, preventing partial updates to the database.</p> <p>Just like a connection, the transaction can be passed to any query generated with the ORM:</p> <pre><code>let user = User::find(15)\n    .fetch_one(&amp;mut transaction)\n    .await?;\n</code></pre>"},{"location":"models/connection-pool/#waiting-for-connections","title":"Waiting for connections","text":"<p>When all available connections are checked out, the call to <code>Pool::connection()</code> will wait (and asynchronously block) until a connection is returned to the pool. If a connection is not returned in time, an timeout error will be returned, unblocking the request and allowing it to handle the situation gracefully.</p>"},{"location":"models/create-records/","title":"Create records","text":"<p>Rwf can create model records in one of two ways:</p> <ul> <li><code>Model::save</code> method which is called on an instance of a struct implementing the <code>Model</code> trait</li> <li><code>Model::create</code> method which accepts the column names and their respective values as input</li> </ul>"},{"location":"models/create-records/#saving-models","title":"Saving models","text":"<p>Using our <code>User</code> model from our previous example, we can create a new record by instantiating a new instance of the <code>User</code> struct and calling <code>save</code>:</p> <pre><code>let user = User {\n    id: None,\n    email: \"admin@example.com\".to_string(),\n    created_at: OffsetDateTime::now_utc(),\n};\n\nlet user = user\n    .save()\n    .fetch(&amp;mut conn)\n    .await?;\n</code></pre> <p>Note</p> <p>The <code>id</code> field is set to <code>None</code>. This ensures that the database assigns it a value automatically, and that this value is unique.</p> <p>Calling <code>save</code> on a model struct with the <code>id</code> set to <code>None</code> produces the following query:</p> <pre><code>INSERT INTO \"users\" (\"email\", \"created_at\") VALUES ($1, $2) RETURNING *\n</code></pre>"},{"location":"models/create-records/#using-table-defaults","title":"Using table defaults","text":"<p>If you don't want to specify some columns when creating records and your database schema has configured defaults, you can use the <code>Model::create</code> method instead:</p> RustSQL <pre><code>let user = User::create(&amp;[\n    (\"email\", \"admin@example.com\"),\n])\n.fetch(&amp;mut conn)\n.await?\n</code></pre> <pre><code>INSERT INTO \"users\" (\"email\") VALUES ($1) RETURNING *\n</code></pre> <p>Any columns not specified in the <code>INSERT</code> statement will be automatically filled in with column defaults. For example, the <code>created_at</code> column specified in our previous example has a default value <code>NOW()</code>, the current database time.</p>"},{"location":"models/create-records/#unique-constraints","title":"Unique constraints","text":"<p>It's very common to place unique constraints on certain columns in a table to avoid duplicate records. For example, the <code>\"users\"</code> table would typically have a unique constraint on the <code>email</code> column, ensuring that no two users have the same email address.</p> <p>To handle unique constraints, Rwf can update a record in-place if one exists already matching the constraint:</p> RustSQL <pre><code>let user = User::create(&amp;[\n  (\"email\", \"admin@example.com\")\n])\n.unique_by(&amp;[\"email\"])\n.fetch(&amp;mut conn)\n.await?;\n</code></pre> <pre><code>INSERT INTO \"users\" (\"email\") VALUES ($1)\nON CONFLICT (\"email\") DO UPDATE\nSET \"email\" = EXCLUDED.\"email\"\nRETURNING *\n</code></pre>"},{"location":"models/create-records/#optionally-create-records","title":"Optionally create records","text":"<p>If the record matching the <code>INSERT</code> statement exists already, Rwf supports returning the existing row without performing an update:</p> RustSQL <pre><code>let user = User::find_or_create_by(&amp;[\n  (\"email\", \"user1@example.com\")\n])\n.fetch(&amp;mut conn)\n.await?;\n</code></pre> <pre><code>SELECT * FROM \"users\" WHERE \"email\" = $1;\nINSERT INTO \"users\" (\"email\") VALUES ($1) RETURNING *;\n</code></pre> <p>This executes up to two queries, starting with a <code>SELECT</code> to see if a row already exists, and if it doesn't, an <code>INSERT</code> to create it.</p>"},{"location":"models/create-records/#combining-with-a-unique-constraint","title":"Combining with a unique constraint","text":"<p>In busy web apps which execute thousands of queries per second, it's entirely possible for a record to be created between the time the <code>SELECT</code> query returns no rows and an <code>INSERT</code> query is sent to the database. In this case, a unique constraint violation error will be returned. To avoid this, it's possible to combine <code>unque_by</code> with <code>find_or_create_by</code> executed inside a single transaction:</p> RustSQL <pre><code>// Start a transaction explicitely.\nlet transaction = Pool::transaction().await?;\n\nlet user = User::find_or_create_by(&amp;[\n  (\"email\", \"user1@example.com\")\n])\n.unique_by(&amp;[\"email\"])\n.fetch(&amp;mut transaction)\n.await?;\n\n// Commit the transaction.\ntransaction.commit().await?;\n</code></pre> <p>A transaction is started explicitly: <pre><code>BEGIN\n</code></pre></p> <p>Afterwards, the ORM attempts to find a record matching the columns in the <code>INSERT</code> statement:</p> <pre><code>SELECT * FROM \"users\" WHERE \"email\" = $1\n</code></pre> <p>If this query returns a row, no more queries are executed. Otherwise, an <code>INSERT</code> query with <code>ON CONFLICT</code> clause is sent to the database:</p> <pre><code>INSERT INTO \"users\" (\"email\") VALUES ($1)\nON CONFLICT (\"email\") DO UPDATE\nSET \"email\" = EXCLUDED.\"email\"\nRETURNING *\n</code></pre> <p>Finally, the transaction is committed to the database:</p> <pre><code>COMMIT\n</code></pre>"},{"location":"models/custom-queries/","title":"Custom queries","text":"<p>Sometimes the ORM is not enough and you need to write a complex query by hand. Rwf provides an easy way to execute arbitrary queries and map the results to a model struct:</p> <pre><code>let users = User::find_by_sql(\"SELECT * FROM users ORDER BY RANDOM() LIMIT 1\")\n  .fetch_all(&amp;mut conn)\n  .await?;\n</code></pre> <p>Note</p> <p>Since this query is not generated by the ORM, you need to make sure to return all the necessary columns and correct data types to map the results to the Rust struct.</p>"},{"location":"models/custom-queries/#use-the-database-driver-directly","title":"Use the database driver directly","text":"<p>If you want to bypass the ORM entirely and just execute queries, you can do so by checking out a connection and calling the <code>query_cached</code> method on it:</p> <pre><code>let mut conn = Pool::connection().await?;\n\nlet results = conn\n    .query_cached(\"SELECT * FROM wherever WHERE column = $1\", &amp;[5])\n    .await?;\n</code></pre> <p>Rwf uses <code>tokio_postgres</code> underneath to talk to Postgres, so you'll receive a <code>Vec&lt;tokio_postgres::Row&gt;</code> as a result of executing that function.</p> <p>Since <code>tokio_postgres</code> uses prepared statements, <code>query_cached</code> ensures that identical queries are not prepared more than once per connection. If you want to bypass that and use <code>tokio_postgres</code> directly, you can use <code>client()</code> instead:</p> <pre><code>let mut conn = Pool::connection().await?;\n\n// Returns a `tokio_postgres::Client`\nlet client = conn.client();\n\nclient\n    .execute(\"SELECT 1\", &amp;[])\n    .await?;\n</code></pre>"},{"location":"models/debug-queries/","title":"Debug queries","text":"<p>When building queries using the ORM, the end result can be inspected by calling <code>to_sql()</code>:</p> RustOutput <pre><code>let query = User::all()\n  .filter(\"created_at\", Value::Null)\n  .limit(5)\n  .to_sql();\nprintln!(\"Query: {}\", query);\n</code></pre> <pre><code>Query: SELECT * FROM \"users\" WHERE \"created_at\" IS NULL LIMIT 5\n</code></pre> <p>The query will not be sent to the database, so it's safe to inspect all queries, no matter if they are performant or not.</p>"},{"location":"models/debug-queries/#query-plan","title":"Query plan","text":"<p>Visual inspection of the query is often not sufficient to understand query performance. For this purpose, databases like PostgreSQL provide the <code>EXPLAIN</code> functionality which, instead of executing the query, produces an execution plan:</p> RustSQLOutput <pre><code>let plan = User::find(15)\n  .explain(&amp;mut conn)\n  .await?;\nprintln!(\"{}\", plan);\n</code></pre> <pre><code>EXPLAIN SELECT * FROM \"users\" WHERE \"id\" = $1\n</code></pre> <pre><code>Seq Scan on users  (cost=0.00..25.00 rows=6 width=40)\nFilter: (id = 5)\n</code></pre> <p>When optimizing queries, this functionality is useful for finding queries that should be using indexes but perform a sequential scan instead.</p>"},{"location":"models/fetch-records/","title":"Fetch records","text":""},{"location":"models/fetch-records/#retrieve-by-primary-key","title":"Retrieve by primary key","text":"<p>Retrieving a record by primary key method accepts an integer and returns a single row corresponding to where the value of the <code>id</code> column equals to the integer:</p> RustSQL <pre><code>let user = User::find(15)\n    .fetch(&amp;mut conn)\n    .await?\n\nassert_eq!(user.id, 15);\n</code></pre> <pre><code>SELECT * FROM \"users\" WHERE \"id\" = $1\n</code></pre>"},{"location":"models/fetch-records/#searching-records","title":"Searching records","text":"<p>Rwf supports searching records by any column in its respective table. For example, the <code>User</code> model has three columns, all of which are searchable:</p> RustSQLPlaceholders <pre><code>use time::Duration;\n\nlet users = User::all()\n  .filter(\"email\", \"admin@example.com\")\n  .filter_gte(\"created_at\", OffsetDateTime::now_utc() - Duration::hours(1))\n  .fetch_all(&amp;mut conn)\n  .await?\n\nassert_eq!(users.len(), 1);\n</code></pre> <pre><code>SELECT * FROM \"users\" WHERE \"email\" = $1 AND \"created_at\" &gt;= $2\n</code></pre> ID Value <code>$1</code> <code>'admin@example.com'</code> <code>$2</code> <code>'2024-10-16T11:27:56-07:00'</code> <p>Rwf supports multiple comparison operations for most data types:</p> Method Operator Example <code>filter</code> <code>=</code> <code>id = 5</code> <code>not</code> / <code>filter_not</code> <code>!=</code> <code>email != 'user@example.com'</code> <code>filter_gt</code> <code>&gt;</code> <code>created_at &gt; NOW()</code> <code>filter_lt</code> <code>&lt;</code> <code>created_at &lt; '2024-10-16'</code> <code>filter_gte</code> <code>&gt;=</code> <code>id &gt;= 5</code> <code>filter_lte</code> <code>&lt;=</code> <code>id &lt;= 25</code> <code>filter</code> <code>IN</code> <code>id IN (1, 2, 3)</code> <code>not</code> <code>NOT IN</code> <code>id NOT IN (4, 5, 6)</code> <p>The <code>filter</code> (and <code>not</code>) methods accept lists of values (in Rust, those are called \"slices\") which translate to the <code>IN</code> and <code>NOT IN</code> filters in SQL respectively:</p> RustSQL <pre><code>let users = User::all()\n  .filter(\"email\", &amp;[\"user1@example.com\", \"user2@example.com\"])\n  .fetch_all(&amp;mut conn)\n  .await?;\n\nassert_eq(users.len(), 2);\n</code></pre> <pre><code>SELECT * FROM \"users\" WHERE \"email\" = ANY($1)\n</code></pre> <p>Note</p> <p><code>= ANY('{1, 2, 3}')</code> is equivalent to <code>IN (1, 2, 3)</code>. In fact, when performing an index scan using an <code>IN</code> (or <code>NOT IN</code>) clause, the query is translated by the database to use <code>ANY</code> instead.</p>"},{"location":"models/fetch-records/#search-by-null","title":"Search by <code>NULL</code>","text":"<p>Searching columns that have no value, i.e. the value is <code>NULL</code>, is a special case and is handled by passing the <code>Value::Null</code> explicitly:</p> RustSQL <pre><code>let users = User::all()\n  .filter(\"email\", Value::Null)\n  .fetch_all(&amp;mut conn)\n  .await?;\n\nassert_eq!(users.len(), 0);\n</code></pre> <pre><code>SELECT * FROM \"users\" WHERE \"email\" IS NULL\n</code></pre> <p>Searching by the opposite, where a column is not <code>NULL</code>:</p> RustSQL <pre><code>let users = User::all()\n  .not(\"email\", Value::Null)\n  .count(&amp;mut conn)\n  .await?;\n</code></pre> <pre><code>SELECT COUNT(*) FROM \"users\" WHERE email IS NOT NULL\n</code></pre>"},{"location":"models/fetch-records/#optional-results","title":"Optional results","text":"<p>When using <code>fetch</code>, if no rows exist, the ORM will return a <code>RecordNotFound</code> error. To avoid this, use <code>fetch_optional</code> which will return an <code>Option</code> instead:</p> RustSQL <pre><code>let user = User::all()\n  .take_one()\n  .fetch_optional(&amp;mut conn)\n  .await?;\n\nassert!(user.is_some());\n</code></pre> <pre><code>SELECT * FROM \"users\" LIMIT 1\n</code></pre>"},{"location":"models/fetch-records/#limiting-results","title":"Limiting results","text":"<p>Fetching many records at once can be inefficient and slow. To limit how many rows your queries return, you can add a <code>LIMIT</code> clause:</p> RustSQL <pre><code>let first_25 = User::all()\n  .limit(25)\n  .order(\"id\")\n  .fetch_all(&amp;mut conn)\n  .await?;\n\nassert_eq!(first_25.len(), 25);\n</code></pre> <pre><code>SELECT * FROM \"users\" ORDER BY \"id\" LIMIT 25\n</code></pre>"},{"location":"models/fetch-records/#paginating-results","title":"Paginating results","text":"<p>Pagination is supported using the <code>OFFSET</code> clause:</p> RustSQL <pre><code>let next_25 = User::all()\n  .limit(25)\n  .offset(25)\n  .order(\"id\")\n  .fetch_all(&amp;mut conn)\n  .await?;\n</code></pre> <pre><code>SELECT * FROM \"users\" ORDER BY \"id\" LIMIT 25 OFFSET 25\n</code></pre>"},{"location":"models/fetch-records/#ordering-results","title":"Ordering results","text":"<p>It's often more efficient and simpler to order rows in the database instead of in the application. Rwf supports ordering by any column in the query, by specifying them using the <code>order</code> method:</p> RustSQL <pre><code>let users = User::all()\n  .order(\"email\")\n  .order((\"id\", \"DESC\"))\n  .fetch_all(&amp;mut conn)\n  .await?;\n</code></pre> <pre><code>SELECT * FROM \"users\" ORDER BY \"email\", \"id\" DESC\n</code></pre>"},{"location":"models/fetch-records/#locking-rows","title":"Locking rows","text":"<p>In busy production applications, it's common for the same row to be accessed from multiple places at the same time. If you'd like to prevent that row from being accessed while you're doing something to it, for example updating it with new values, you can use a row-level lock:</p> RustSQL <pre><code>let transaction = Pool::transaction().await?;\n\nlet user = User::find(15)\n    .lock()\n    .fetch(&amp;mut transaction)\n    .await?;\n\ntransaction.commit().await?;\n</code></pre> <pre><code>BEGIN;\nSELECT * FRON \"users\" WHERE \"id\" = $1 FOR UPDATE;\nCOMMIT;\n</code></pre> <p>The lock on the row(s) returned by a query last only for the duration of the transaction. It's common to use that time to update multiple tables that have some kind of relationship to the row being locked. This mechanism allows to perform atomic operations (all or nothing) in a concurrent environment without data races or inconsistencies.</p>"},{"location":"models/join-models/","title":"Join models","text":"<p>Joining models together allows to build complex search queries spanning multiple database tables. Rwf supports joining models out of the box, but requires a couple of annotations to declare relationships between models.</p>"},{"location":"models/join-models/#define-model-relationship","title":"Define model relationship","text":"<p>Using the <code>User</code> model from our previous example, let's define a <code>Project</code> model, which will record projects created by the users of our fictional web app:</p> <pre><code>#[derive(Clone, macros::Model)]\n#[belongs_to(User)]\nstruct Project {\n    id: Option&lt;i64&gt;,\n    user_id: i64,\n    project_name: f64,\n    completed: bool,\n}\n</code></pre> <p>A few things to unpack here. First, a new macro annotation <code>belongs_to</code> indicates the type of relationship this model has to the <code>User</code> model. In this case, it indicates a \"belongs to\" relationship, meaning each instance of the <code>Project</code> model will have one <code>User</code> associated to it.</p> <p>If we were to create a table for storing records of this model, the query could be:</p> <pre><code>CREATE TABLE projects (\n  id BIGSERIAL PRIMARY KEY,\n  user_id BIGINT NOT NULL REFERENCES users(id),\n  project_name VARCHAR NOT NULL,\n  completed BOOLEAN NOT NULL\n);\n</code></pre>"},{"location":"models/join-models/#naming-convention","title":"Naming convention","text":"<p>The naming convention for foreign keys is the singular form of the table name its referring to, e.g. <code>users</code> becomes <code>user</code>, joined with the name of the primary key, in our case, the <code>id</code> column, producing the <code>user_id</code> foreign key.</p>"},{"location":"models/join-models/#join-tables","title":"Join tables","text":"<p>Specifying the <code>belongs_to</code> relationship allows us to query the <code>Project</code> model and join it to the <code>User</code> model easily:</p> RustSQL <pre><code>let projects = Project::all()\n  .join::&lt;User&gt;()\n  .filter(\"project_name\", \"My first Rwf web app\")\n  .filter(\"email\", \"user@example.com\")\n  .fetch_all(&amp;mut conn)\n  .await?;\n</code></pre> <pre><code>SELECT \"projects\".* FROM \"projects\"\nINNER JOIN \"users\" ON \"projects\".\"user_id\" = \"users\".\"id\"\nWHERE \"project_name\" = $1 AND \"email\" = $2\n</code></pre> <p>Note</p> <p>The <code>join::&lt;Model&gt;</code> method accepts a generic argument specifying which model we are joining to. If the association between <code>Project</code> and <code>User</code> doesn't exist, the Rust compiler will return an error. This helps us avoid common errors by accidentally joining tables that don't have a relationship.</p>"},{"location":"models/join-models/#disambiguating-fields","title":"Disambiguating fields","text":"<p>More often than not, two tables have columns with the same name. The most obvious example of this is the primary key, the <code>id</code> column by default, which exists in all Rwf models. To specify which table &amp; column a query is referring to, Rwf provides the ability to fully qualify the column with the table name:</p> RustSQL <pre><code>let projects = Project::all()\n  .join::&lt;User&gt;()\n  .filter(User::column(\"id\"), 5)\n  .take_one()\n  .fetch(&amp;mut conn)\n  .await?;\n</code></pre> <pre><code>SELECT * FROM \"projects\"\nINNER JOIN \"users\" ON \"projects\".\"user_id\" = \"users\".\"id\"\nWHERE \"users\".\"id\" = $1\nLIMIT 1\n</code></pre>"},{"location":"models/join-models/#inverse-relationship","title":"Inverse relationship","text":"<p>The <code>Project</code> model defines a <code>belongs_to</code> relationship to the <code>User</code> model, but the <code>User</code> model doesn't define one to the <code>Project</code> model. If we attempt to join <code>\"users\"</code> to <code>\"projects\"</code> (instead of the other way around), we will get a Rust compiler error. To avoid this, we can specify the inverse relationship on the <code>User</code> model, like so:</p> <pre><code>#[derive(Clone, macros::Model)]\n#[has_many(Project)]\nstruct User {\n    id: Option&lt;i64&gt;,\n    email: String,\n    created_at: OffsetDateTime,\n}\n</code></pre> <p>Joining <code>\"users\"</code> to <code>\"projects\"</code> now is possible and can produce interesting queries, for example:</p> RustSQL <pre><code>let beginners = User::all()\n  .join::&lt;Project&gt;()\n  .filter(\"project_name\", \"Rust Programming Language: Introduction\")\n  .filter(\"completed\", false)\n  .fetch_all(&amp;mut conn)\n  .await?;\n</code></pre> <pre><code>SELECT \"users\".* FROM \"users\"\nINNER JOIN \"projects\" ON \"users\".\"id\" = \"projects\".\"user_id\"\nWHERE \"project_name\" = $1 AND \"completed_at\" = $2\n</code></pre>"},{"location":"models/join-models/#additional-relationships","title":"Additional relationships","text":"<p><code>belongs_to</code> and <code>has_many</code> are the most common relationships, but it's possible to define more. For example, the \"has one\" relationship where one row in a table has only one row related to it in another table is a common relationship which doesn't have its own macro annotation.</p> <p>To implement this relationship, specify the <code>belongs_to</code> relationship, and add a <code>UNIQUE</code> constraint on the foreign key referring to that table. For example, if we wanted to allow the users of our fictional web app to have only one project, we can enforce this by altering the <code>\"projects\"</code> table:</p> <pre><code>ALTER TABLE \"projects\" ALTER COLUMN \"user_id\" UNIQUE;\n</code></pre> <p>This creates a unique index on that column, so if a user attempts to create a second project, the database will return an error.</p>"},{"location":"models/join-models/#joining-multiple-tables","title":"Joining multiple tables","text":"<p>Joining across multiple tables is possible as long as there exists at least one relationship between all tables in the query. For example, if we had another model called <code>Goal</code> which belongs to a <code>Project</code>, we would be able to join <code>\"users\"</code> to <code>\"goals\"</code> by going through <code>\"projects\"</code> first:</p> <pre><code>#[derive(Clone, macros::Model)]\n#[belongs_to(Project)]\nstruct Goal {\n    id: Option&lt;i64&gt;,\n    project_id: i64,\n    priority: i64,\n    goal_name: String,\n    achived: bool,\n}\n\n#[derive(Clone, macros::Model)]\n#[has_many(Goal)]\nstruct Project { /* ... */ }\n</code></pre> <p>The join will have to use the <code>join_nested</code> function instead, since <code>User</code> isn't directly related to <code>Goal</code>:</p> RustSQL <pre><code>let users = User::all()\n    .join_nested(Project::join::&lt;Goal&gt;())\n    .filter(\"goal_name\", \"Learn a lot\")\n    .fetch_all(&amp;mut conn)\n    .await?;\n</code></pre> <pre><code>SELECT \"users\".* FROM \"users\"\nINNER JOIN \"projects\" ON \"projects\".\"user_id\" = \"users\".\"id\"\nINNER JOIN \"goals\" ON \"goals\".\"project_id\" = \"projects\".\"id\"\nWHERE \"goal_name\" = $1\n</code></pre>"},{"location":"models/migrations/","title":"Migrations","text":"<p>Migrations are a systematic way of changing your database schema. They allow to add/remove/change database tables in a predictable and ordered way, and to make sure all versions of your database, in development and in production, have the same schema.</p> <p>Rwf supports migrations out of the box. To use this feature, install Rwf CLI, if you haven't already:</p> <pre><code>cargo install rwf-cli\n</code></pre> <p>The CLI should be available globally. You can check if it's working correctly by running:</p> CommandOutput <pre><code>rwf-cli --help\n</code></pre> <pre><code>Rust Web Framework CLI\n\nUsage: rwf-cli &lt;COMMAND&gt;\n\nCommands:\n  migrate  Manage migrations\n  setup    Setup the project for Rwf\n  help     Print this message or the help of the given subcommand(s)\n\nOptions:\n  -h, --help     Print help\n  -V, --version  Print version\n</code></pre>"},{"location":"models/migrations/#run-migrations","title":"Run migrations","text":"<p>If it's your first time setting up a Rwf app, you should run migrations before starting the server. To run migrations, change directory to the project root (where <code>Cargo.toml</code> is located) and run:</p> <pre><code>rwf-cli migrate run\n</code></pre> <p>This command will automatically read all files in the <code>migrations</code> folder, and run the necessary ones in the correct order. For instance, if a migration is already applied to your database, Rwf will skip it and run the next one.</p>"},{"location":"models/migrations/#create-new-migration","title":"Create new migration","text":"<p>If you're looking to change your database schema, e.g. by adding a new table, you can do so in a reproducible way with a migration. To create a new migration, run the following command:</p> CommandOutput <pre><code>rwf-cli migrate add --name \"&lt;migration name&gt;\"\n</code></pre> <pre><code>created \"migrations/1729119889028371278_unnamed.up.sql\"\ncreated \"migrations/1729119889028371278_unnamed.down.sql\"\n</code></pre> <p>Migrations are placed inside the <code>&lt;PROJECT_ROOT&gt;/migrations</code> folder. If this folder doesn't exist, <code>rwf-cli</code> will create it automatically.</p> <p>The migration name is optional. By default the migration will be \"unnamed\", but it's nice to name it something recognizable; this helps others working on your project (including future you) to know what was changed.</p>"},{"location":"models/migrations/#writing-migrations","title":"Writing migrations","text":"<p>The <code>migrate add</code> command creates two files in the <code>migrations</code> folder: the \"up\" migration and the \"down\" migration. The \"up\" migration contains the desired changes to the database schema, while the \"down\" migration contains commands to revert those changes.</p> <p>Note</p> <p>Having the \"down\" migration is technically optional but is very helpful in case the migration doesn't work in production, and you need to revert your changes and try again. Additionally, without the correct \"down\" migration, commands like <code>migrate flush</code> won't work correctly.</p> <p>For example, if you want to add a <code>\"users\"</code> table to your database, you can write the following migration:</p> Up migrationDown migration <pre><code>CREATE TABLE users (\n    id BIGSERIAL PRIMARY KEY,\n    email VARCHAR UNIQUE NOT NULL,\n    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()\n);\n</code></pre> <pre><code>DROP TABLE users;\n</code></pre> <p>Once finished, applying the migration can be done by running the <code>migrate run</code> command:</p> CommandOutput <pre><code>rwf-cli migrate run\n</code></pre> <pre><code>migration \"1729119889028371278_unnamed\" applied\n</code></pre>"},{"location":"models/migrations/#revert-migration","title":"Revert migration","text":"<p>If something went wrong, or you'd like to make more changes without creating another migration (in development), you can revert the last migration by running:</p> CommandOutput <pre><code>rwf-cli migrate revert\n</code></pre> <pre><code>migration \"1729119889028371278_unnamed\" reverted\n</code></pre> <p>The <code>revert</code> command automatically executes the \"down\" file for the last migration. If you'd like to revert more than one migration, specify the version to which you want to revert to, by passing the <code>--version &lt;VERSION&gt;</code> argument.</p> <p>Re-running the last migration can be done by running <code>migrate run</code> command again.</p>"},{"location":"models/migrations/#flush-the-database","title":"Flush the database","text":"<p>In local development, it's sometimes useful to delete everything in your database and start again. To do so, you can run the <code>migrate flush</code> command. This command will revert all migrations in reverse order, and re-apply them in normal order again.</p> <p>Warning</p> <p>Running <code>rwf-cli migrate flush</code> will delete all your data. Never run this command in production. To protect against accidental misuse, the command will not do anything unless a <code>--yes</code> flag is passed to it.</p>"},{"location":"models/scopes/","title":"Scopes","text":"<p>A scope, in ORM language, is a commonly used query which can be saved and re-used in different parts of the code without having to type it out multiple times.</p>"},{"location":"models/scopes/#declare-scopes","title":"Declare scopes","text":"<p>Rwf provides the <code>Scope&lt;Model&gt;</code> generic type which indicates that the value is a non-executed query. It's possible to declare scopes directly on the model struct (or as a separate function anywhere else), for example:</p> <pre><code>impl User {\n    fn admins() -&gt; Scope&lt;User&gt; {\n        User::all()\n            .filter(\"email\", &amp;[\n                \"admin@example.com\",\n                \"boss@example.com\",\n                \"joe@example.com\",\n            ])\n    }\n}\n</code></pre> <p>The query is now re-usable anywhere in the code base:</p> <pre><code>let admins = User::admins()\n    .fetch_all(&amp;mut conn)\n    .await?;\n</code></pre> <p>Note</p> <p>When defining scopes, it's important not to execute the scope before returning it. In the example above, you'll note that we don't call <code>fetch</code>, or <code>fetch_all</code> but return the result of calling <code>filter</code> instead.</p>"},{"location":"models/scopes/#chain-scopes","title":"Chain scopes","text":"<p>It's possible to build very complex queries easily, by chaining multiple scopes together:</p> <pre><code>impl User {\n    /// Admins created in the last hour.\n    fn new_admins() -&gt; Scope&lt;User&gt; {\n        User::admins()\n            .filter_gte(\n                \"created_at\",\n                OffsetDateTime::now_utc() - Duration::hours(1),\n            )\n    }\n\n    /// New admins ordered by primary key.\n    fn new_admins_ordered() -&gt; Scope&lt;User&gt; {\n        User::new_admins()\n            .order(\"id\")\n    }\n}\n</code></pre>"},{"location":"models/scopes/#scopes-and-joins","title":"Scopes and joins","text":"<p>It's entirely possible to save complex joins in a scope, for example:</p> <pre><code>impl User {\n    /// Users who understand how to write Rust macros.\n    fn intermediate() -&gt; Scope&lt;User&gt; {\n        User::all()\n          .join::&lt;Project&gt;\n          .filter(\"project_name\", \"How to write Rust macros\")\n          .filter(\"completed\", true)\n    }\n}\n</code></pre>"},{"location":"models/security/","title":"Security","text":"<p>The ORM is a common place in a web app where malicious users attempt to inject bad data in order to extract information they should not have access to or to damage the web app in some way, by deleting important data for example.</p> <p>To protect against what we call SQL injection attacks<sup>1</sup>, the Rwf ORM takes multiple precautions.</p>"},{"location":"models/security/#prepared-statements","title":"Prepared statements","text":"<p>Rwf uses prepared statements which separate the query text from user-specified values. The values themselves cannot be injected into the query, so the most common type of SQL injection attack becomes hard to impossible to execute.</p> <p>You'll note that all of our SQL examples use placeholders, values starting with the <code>$</code> sign, to indicate where values should go. The placeholders are replaced by the database once both the query text and the values are received, so malicious values can never leak into the query language itself.</p>"},{"location":"models/security/#escaping-user-supplied-values","title":"Escaping user-supplied values","text":"<p>For other values like column names, Rwf escapes them in order to avoid modifying queries in unexpected ways.</p> RustSQLError <pre><code>let oops = User::all()\n  .filter(\"\\\";DROP TABLE users;\", 5)\n  .fetch(&amp;mut conn)\n  .await?;\n</code></pre> <pre><code>SELECT * FROM \"users\" WHERE \"\"\";DROP TABLE users;\" = $1;\n</code></pre> <pre><code>ERROR:  column \"\";DROP TABLE users;\" does not exist\n</code></pre> <ol> <li> <p>A SQL injection attack is injecting custom SQL into a query, in order to extract data from database tables.\u00a0\u21a9</p> </li> </ol>"},{"location":"models/update-records/","title":"Update records","text":"<p>Rwf allows to update records using two mechanisms:</p> <ul> <li>Update a single record by calling <code>Model::save</code> on an instance of a model</li> <li>Update multiple records using one query by using <code>Model::update_all</code></li> </ul>"},{"location":"models/update-records/#update-a-single-record","title":"Update a single record","text":"<p>Updating a single record can be done by mutating struct instance fields and calling <code>save</code>:</p> RustSQL <pre><code>// Get an instance of a User model\nlet user = User::all()\n  .take_one()\n  .fetch(&amp;mut conn)\n  .await?;\n\n// Change a field\nuser.created_at = OffsetDateTime::now_utc();\n\n// Update the record\nlet user = user\n  .save()\n  .fetch(&amp;mut conn)\n  .await?;\n</code></pre> <pre><code>UPDATE \"users\" SET \"email\" = $1, \"created_at\" = $2 WHERE \"id\" = $3 RETURNING *\n</code></pre> <p>Instead of fetching the record from the database, you can just instantiate one manually, as long as you know the desired primary key value:</p> <pre><code>let user = User {\n  id: Some(25),\n  email: \"new_email@example.com\",\n  created_at: OffsetDateTime::now_utc(),\n};\n\nlet user = user\n  .save()\n  .fetch(&amp;mut conn)\n  .await?;\n</code></pre> <p>This is very similar to creating new records, except that we set the <code>id</code> field to a known value. When the <code>id</code> is set to <code>Some(i64)</code>, Rwf assumes the record exists in the database, meanwhile if the <code>id</code> is <code>None</code>, Rwf will attempt to create one instead.</p>"},{"location":"models/update-records/#update-multiple-records","title":"Update multiple records","text":"<p>Updating multiple records in one query is possible by searching for them first and then calling <code>update_all</code>:</p> RustSQL <pre><code>let users = User::all()\n  .filter_gte(\"created_at\", OffsetDateTime::now_utc() - Duration::hours(1))\n  .update_all(&amp;[\n    (\"created_at\", OfssetDateTime::now_utc()),\n  ])\n  .fetch_all(&amp;mut conn)\n  .await?;\n</code></pre> <pre><code>UPDATE \"users\" SET created_at = $1 WHERE created_at &gt;= $2\n</code></pre>"},{"location":"views/","title":"Views basics","text":"<p>Rwf comes with a templating library that can generate dynamic pages. Dynamic templates allow you to create unique HTML pages on the fly, and libraries like Turbo can use it in a way that feels like a native frontend application.</p>"},{"location":"views/#what-are-views","title":"What are views?","text":"<p>Views are the V in MVC: they control what your users see and how they experience your web app. Separating views from controllers allows controllers to reuse similar parts of your web app on different pages without code duplication.</p>"},{"location":"views/#using-javascript-frontends","title":"Using JavaScript frontends","text":"<p>If you prefer to build your frontend with JavaScript libraries like React or Vue, take a look at Rwf's REST API documentation. Rwf templates are not required to build web applications.</p>"},{"location":"views/#learn-more","title":"Learn more","text":"<ul> <li>Templates</li> <li>Turbo</li> </ul>"},{"location":"views/templates/","title":"Templates overview","text":"<p>Dynamic templates are a mix of HTML and a programming language which directs how the HTML is displayed. For example, if you have a profile page for your web app users, you would want each of your users to have a page unique to them. To achieve this, you would write only one template and substitute unique aspects of each using template variables, for example:</p> <pre><code>&lt;div class=\"profile\"&gt;\n  &lt;h2&gt;&lt;%= username %&gt;&lt;/h2&gt;\n  &lt;p&gt;&lt;%= bio %&gt;&lt;/p&gt;\n&lt;/div&gt;\n</code></pre> <p>The variables <code>username</code> and <code>bio</code> can be substituted for values unique to each of your users, for example:</p> RustOutput <pre><code>use rwf::prelude::*;\n\nlet template = Template::from_str(r#\"\n&lt;div class=\"profile\"&gt;\n  &lt;h2&gt;&lt;%= username %&gt;&lt;/h2&gt;\n  &lt;p&gt;&lt;%= bio %&gt;&lt;/p&gt;\n&lt;/div&gt;\n\"#)?;\n\nlet html = template.render([\n  (\"username\", \"Alice\"),\n  (\"bio\", \"I like turtles\")\n])?;\n\nprintln!(\"{}\", html);\n</code></pre> <pre><code>&lt;div class=\"profile\"&gt;\n  &lt;h2&gt;Alice&lt;/h2&gt;\n  &lt;p&gt;I like turtles&lt;/p&gt;\n&lt;/div&gt;\n</code></pre> <p>Templates help reuse HTML (and CSS, JavaScript) just like regular functions and structs help reuse code.</p>"},{"location":"views/templates/#learn-more","title":"Learn more","text":"<ul> <li>Variables</li> <li>For loops</li> <li>If statements</li> </ul>"},{"location":"views/templates/caching/","title":"Template cache","text":"<p>Templates are compiled and evaluated on the fly. This is handy for local development, allowing you to modify the template without recompiling the Rust app or restarting the web server, but in production could be an unnecessary performance hindrance.</p> <p>The template cache makes sure a template is compiled only once. All subsequent executions of the template will use an internal representation and are much faster to run.</p>"},{"location":"views/templates/caching/#using-the-cache","title":"Using the cache","text":"<p>To use the template cache, templates must be stored on disk, for example in a <code>templates</code> directory. Loading a template should use the <code>Template::load</code> function:</p> <pre><code>let template = Template::load(\"templates/index.html\")?;\n</code></pre> <p>The first time the template is loaded, it will be fetched from disk and compiled. Once compiled, it will be stored in the cache to be reused by all subsequent calls to <code>Template::load</code>.</p>"},{"location":"views/templates/caching/#enable-the-cache","title":"Enable the cache","text":"<p>The template cache is disabled by default. To enable it, toggle the <code>cache_templates</code> setting in configuration.</p>"},{"location":"views/templates/for-loops/","title":"For loops","text":"<p>Rwf templates have only one kind of for loop: for each. This allows writing more reliable templates, and to avoid common bugs like infinite loops, which will stall a web app in production.</p> <p>A for loop can iterate over a list of values, for example:</p> <pre><code>&lt;ul&gt;\n&lt;% for value in list %&gt;\n  &lt;li&gt;&lt;%= value %&gt;&lt;/li&gt;\n&lt;% end %&gt;\n&lt;/ul&gt;\n</code></pre> <p>Template lists, unlike Rust's <code>Vec</code>, can hold variables of different data types, and are dynamically evaluated at runtime:</p> TemplateOutput <pre><code>&lt;% for value in [\"one\", 2 * 5, 3/1.5] %&gt;\n&lt;%= value %&gt;\n&lt;% end %&gt;\n</code></pre> <pre><code>one\n10\n2.0\n</code></pre>"},{"location":"views/templates/for-loops/#do-n-times","title":"Do n times","text":"<p>If you need to execute some code multiple times, templates come with a handy <code>times</code> function:</p> TemplateOutput <pre><code>&lt;% for n in 5.times %&gt;\n  &lt;li&gt;&lt;%= n %&gt;.&lt;/li&gt;\n&lt;% end %&gt;\n</code></pre> <pre><code>&lt;li&gt;1.&lt;/li&gt;\n&lt;li&gt;2.&lt;/li&gt;\n&lt;li&gt;3.&lt;/li&gt;\n&lt;li&gt;4.&lt;/li&gt;\n&lt;li&gt;5.&lt;/li&gt;\n</code></pre>"},{"location":"views/templates/functions/","title":"Functions","text":"<p>Templates provide a number of functions that manipulate variables. Each variable data type has its own set of functions, which you can call using the dot (<code>.</code>) notation, for example:</p> TemplateOutput <pre><code>&lt;%= \"lowercase\".upper %&gt;\n</code></pre> <pre><code>LOWERCASE\n</code></pre>"},{"location":"views/templates/functions/#integer-functions","title":"Integer functions","text":"Function Description <code>abs</code> Get the absolute (non-negative) value. <code>to_string</code> Convert an integer to a string. <code>to_s</code> Alias for <code>to_string</code>. <code>to_float</code> Convert integer to float. <code>to_f</code> Alias for <code>to_float</code>. <code>times</code> Create a list of integers, starting at 0 and ending with the integer."},{"location":"views/templates/functions/#examples","title":"Examples","text":"<p>Getting the absolute value of an integer:</p> TemplateOutput <pre><code>&lt;% if -5.abs == 5 %&gt;\n&lt;h1&gt;True&lt;h1&gt;\n&lt;% end %&gt;\n</code></pre> <pre><code>&lt;h1&gt;True&lt;/h1&gt;\n</code></pre> <p>Converting an integer to a string:</p> TemplateOutput <pre><code>&lt;% if 25.to_s == \"25\" %&gt;\n&lt;h1&gt;True&lt;h1&gt;\n&lt;% end %&gt;\n</code></pre> <pre><code>&lt;h1&gt;True&lt;/h1&gt;\n</code></pre>"},{"location":"views/templates/functions/#float-functions","title":"Float functions","text":"Function Description <code>abs</code> Get the absolute (non-negative) value. <code>to_string</code> Convert an integer to a string. <code>to_s</code> Alias for <code>to_string</code>. <code>to_integer</code> Convert float to integer, rounding it. <code>to_i</code> Alias for <code>to_integer</code>. <code>round</code> Round the float to the nearest whole value. <code>ceil</code> Round the float to the upper whole value. <code>floor</code> Round the float to the lower whole value."},{"location":"views/templates/functions/#examples_1","title":"Examples","text":"<p>Comparing a float and an integer:</p> TemplateOutput <pre><code>&lt;% if 25 == 25.4.to_i %&gt;\n&lt;h1&gt;True&lt;h1&gt;\n&lt;% end %&gt;\n</code></pre> <pre><code>&lt;h1&gt;True&lt;/h1&gt;\n</code></pre>"},{"location":"views/templates/functions/#string-functions","title":"String functions","text":"Function Description <code>to_uppercase</code> Convert string to uppercase lettering. <code>uppper</code> Alias for <code>to_uppercase</code>. <code>to_lowercase</code> Convert string to lowercase lettering. <code>lower</code> Alias for <code>to_uppercase</code>. <code>trim</code> Remove leading and trailing spaces and new lines."},{"location":"views/templates/functions/#examples_2","title":"Examples","text":"<p>Trim a string with extra leading and trailing spaces:</p> TemplateOutput <pre><code>&lt;p&gt;&lt;%= \"  messy string  \" %&gt;&lt;/p&gt;\n</code></pre> <pre><code>&lt;p&gt;messsy string&lt;/p&gt;\n</code></pre>"},{"location":"views/templates/functions/#list-functions","title":"List functions","text":"Function Description <code>enumerate</code> Convert the list to a list of element position and element tuples. <code>reverse</code> Convert the list to a new list of elements positioned from end to beginning. <code>rev</code> Alias for <code>reverse</code>."},{"location":"views/templates/functions/#examples_3","title":"Examples","text":"<p>Enumerate a list:</p> TemplateOutput <pre><code>&lt;% for tuple in [\"one\", \"two\"].enumerate %&gt;\n&lt;li&gt;&lt;%= tuple.0 %&gt; &amp;dash; &lt;%= tuple.1 %&gt;\n&lt;% end %&gt;\n</code></pre> <pre><code>&lt;li&gt;0 - one &lt;li&gt;\n&lt;li&gt;1 - two&lt;/li&gt;\n</code></pre>"},{"location":"views/templates/functions/#hashes","title":"Hashes","text":"Function Description <code>keys</code> Create a list of hash keys. <code>values</code> Create a list of hash values. <code>iter</code> Create a list of tuples, mapping keys to values. Used for iteration over a hash."},{"location":"views/templates/if-statements/","title":"If statements","text":"<p>If statements allow you to control the flow of templates, conditionally displaying some elements while hiding others. For example, if a variable is \"falsy\", you can hide entire sections of your website:</p> <pre><code>&lt;% if logged_in %&gt;\n  &lt;!-- profile page --&gt;\n&lt;% else %&gt;\n  &lt;!-- login page --&gt;\n&lt;% end %&gt;\n</code></pre> <p>If statements start with <code>if</code> and must always finish with <code>end</code>.</p>"},{"location":"views/templates/if-statements/#expressions","title":"Expressions","text":"<p>If statements support evaluating large expressions for truthiness, for example:</p> <pre><code>&lt;% if var.lower + \"_\" + bar.upper == \"lo_HI\" %&gt;\n  &lt;!-- do something --&gt;\n&lt;% end %&gt;\n</code></pre> <p>While it's advisable to write simple if statements and delegate complex logic to views where the Rust compiler can be more helpful, Rwf template language is almost Turing-complete and can be used to write arbitrarily complex templates.</p>"},{"location":"views/templates/if-statements/#operator-precedence","title":"Operator precedence","text":"<p>Templates respect operator precedence, e.g., multiplication is performed before addition, unless parentheses are specified (which are also supported).</p>"},{"location":"views/templates/if-statements/#else-if","title":"Else If","text":"<p>If statements support else if blocks (written as <code>elsif</code>), evaluating multiple expressions and executing the first one which evaluates to true:</p> <pre><code>&lt;% if one %&gt;\n  &lt;!-- one --&gt;\n&lt;% elsif two %&gt;\n  &lt;!-- two --&gt;\n&lt;% elsif three %&gt;\n  &lt;!-- three --&gt;\n&lt;% else %&gt;\n  &lt;!-- I guess it's four? ---&gt;\n&lt;% end %&gt;\n</code></pre>"},{"location":"views/templates/nomenclature/","title":"Nomenclature","text":""},{"location":"views/templates/nomenclature/#expressions","title":"Expressions","text":"<p>Expressions are a combination of terms and operators which evaluate to a single value, for example:</p> TemplateOutput <pre><code>&lt;%= 5 * 2 / 10 %&gt;\n</code></pre> <pre><code>1\n</code></pre>"},{"location":"views/templates/nomenclature/#statements","title":"Statements","text":"<p>Statements are commands given to the template language interpreter to do something, e.g. output the value of an expression, or execute a for loop.</p>"},{"location":"views/templates/partials/","title":"Partials","text":"<p>Partials are templates that can be rendered inside other templates to facilitate reuse of frontend code. For example, if you have a navigation menu in your app, you would want it to look the same on all pages, but you don't want to implement the same menu many times. To achieve this, you can write a partial and insert it in all templates where it's needed.</p>"},{"location":"views/templates/partials/#writing-partials","title":"Writing partials","text":"<p>A partial is just another template. It has to be stored on disk, in a directory reachable from your application, for example <code>templates/partials</code>.</p> <p>Using the navigation menu as an example, we can define a partial in <code>templates/partials/nav.html</code>, as follows:</p> <pre><code>&lt;nav&gt;\n  &lt;ul&gt;\n    &lt;li&gt;&lt;a href=\"/\"&gt;Home&lt;/a&gt;&lt;/li&gt;\n    &lt;li&gt;&lt;a href=\"/profile\"&gt;Profile&lt;/a&gt;&lt;/li&gt;\n  &lt;/ul&gt;\n&lt;/nav&gt;\n</code></pre> <p>Rendering partials can be done in any template, using the special <code>&lt;%%</code> tag, for example:</p> TemplateOutput <pre><code>&lt;html&gt;\n  &lt;head&gt;\n  &lt;!-- ... --&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;%% \"templates/partials/nav.html\" %&gt;\n  &lt;/body&gt;\n&lt;/html&gt;\n</code></pre> <pre><code>&lt;html&gt;\n  &lt;head&gt;\n  &lt;!-- ... --&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;nav&gt;\n      &lt;ul&gt;\n        &lt;li&gt;&lt;a href=\"/\"&gt;Home&lt;/a&gt;&lt;/li&gt;\n        &lt;li&gt;&lt;a href=\"/profile\"&gt;Profile&lt;/a&gt;&lt;/li&gt;\n      &lt;/ul&gt;\n    &lt;/nav&gt;\n  &lt;/body&gt;\n&lt;/html&gt;\n</code></pre>"},{"location":"views/templates/partials/#using-variables","title":"Using variables","text":"<p>Partials can use variables like a regular template. When rendered, they inherit the variables and scope of the template they are used in, for example:</p> PartialTemplate <pre><code>&lt;h1&gt;&lt;%= user.name %&gt;&lt;/h1&gt;\n&lt;p&gt;&lt;%= user.bio %&gt;&lt;/p&gt;\n</code></pre> <pre><code>&lt;% for user in users %&gt;\n  &lt;%% \"templates/partials/user.html\" %&gt;\n&lt;% end %&gt;\n</code></pre>"},{"location":"views/templates/variables/","title":"Variables","text":"<p>Template variables are used to substitute unique information into a reusable template. Rwf supports variables of different kinds, like strings, numbers, lists, and hashes. Complex variables like hashes can be iterated through using for loops.</p>"},{"location":"views/templates/variables/#using-variables","title":"Using variables","text":"<p>Using variables in your templates is typically done by \"printing\" them, or outputting them, into the template text, by placing them between <code>&lt;%=</code> and <code>%&gt;</code> tags:</p> <pre><code>&lt;%= variable %&gt;\n</code></pre> <p>The <code>&lt;%=</code> tag indicates what follows is an expression, which should be evaluated and converted to text for displaying purposes.</p> <p>The <code>%&gt;</code> tag is not specific to printing variables, and indicates the end of a code block inside a template. What follows that tag is just regular text which has no special meaning.</p>"},{"location":"views/templates/variables/#defining-variables","title":"Defining variables","text":"<p>A variable is defined when a template is rendered. Using one of many possible ways to define a context, the variable is given a value at runtime:</p> RustOutput <pre><code>let template = Template::from_str(\"&lt;%= variable %&gt;\")?;\nlet string = template.render([\n    (\"variable\", \"I love pancakes for dinner.\"),\n])?;\nprintln!(\"{}\", string);\n</code></pre> <pre><code>I love pancakes for dinner.\n</code></pre>"},{"location":"views/templates/variables/#missing-variables","title":"Missing variables","text":"<p>It's not uncommon to forget to define variables, especially if a template is large, or used in multiple places in the app where some variables don't have a known value.</p> <p>If an undefined variable is used in a template, Rwf will throw a runtime error. This is good for debugging issues when variables are unintentionally forgotten by the developer. However, if the variable is not always available, you can check if it's defined first:</p> <pre><code>&lt;% if variable %&gt;\n  &lt;p&gt;&lt;%= variable %&gt;&lt;/p&gt;\n&lt;% end %&gt;\n</code></pre> <p>Due to the nature of if statements, if the variable is defined and evaluates to a \"falsy\" value, e.g. <code>0</code>, <code>\"\"</code> (empty string), <code>null</code>, etc., the if statement will not be executed either. This is helpful for handling many similar cases without having to write complex statements.</p>"},{"location":"views/templates/variables/#supported-data-types","title":"Supported data types","text":"<p>Rwf variables support most Rust data types. The conversion between Rust and the template language happens automatically.</p>"},{"location":"views/templates/variables/#number","title":"Number","text":"<p>Rwf supports two kinds of numbers: integers and floating points.</p> <p>An integer is any whole number, negative or positive (including zero). Rust has many integer types, e.g. <code>i8</code>, <code>i32</code>, <code>u64</code>, etc., but the template language converts all of them to an 64-bit singed integer:</p> TemplateOutput <pre><code>&lt;%= 500 %&gt;\n</code></pre> <pre><code>500\n</code></pre> <p>Rust's <code>f32</code> and <code>f64</code> are converted to 64-bit double precision floating point. Operations between integers and floating points are supported, the final result being a float:</p> TemplateOutput <pre><code>&lt;%= 500 + 1.5 %&gt;\n</code></pre> <pre><code>501.5\n</code></pre> <p>Numbers can be converted to strings, floored, ceiled and rounded, for example:</p> TemplateOutput <pre><code>&lt;%= 123.45.round.to_s %&gt;\n</code></pre> <pre><code>123\n</code></pre>"},{"location":"views/templates/variables/#strings","title":"Strings","text":"<p>Using strings in templates can be used in two ways: with the <code>&lt;%=</code> (print) operator, which outputs the string, escaping any dangerous HTML characters, e.g. <code>&lt;</code> becomes <code>&amp;lt;</code>, or using <code>&lt;%-</code> which performs no conversions and prints the string as-is.</p>"},{"location":"views/templates/variables/#string-security","title":"String security","text":"<p>Escaping HTML characters is a good idea in cases where your users are the ones supplying the value of the string. This prevents script injection attacks, e.g. users placing malicious code on your website.</p> <p>Unless you're sure about the provenance of a string, use <code>&lt;%=</code> to output it in templates.</p>"},{"location":"views/templates/variables/#boolean","title":"Boolean","text":"<p>Boolean variables can either be <code>true</code> or <code>false</code>. They map directly to Rust's <code>bool</code> data type.</p>"},{"location":"views/templates/variables/#lists","title":"Lists","text":"<p>Lists are arrays of other template variables, including other lists, strings, numbers, and hashes. In templates, lists can be defined by using square brackets, and iterated on using for loops, for example:</p> TemplateOutput <pre><code>&lt;% for item in [1, 2, \"three\"] %&gt;\n&lt;%= item %&gt;\n&lt;% end %&gt;\n</code></pre> <pre><code>1\n2\nthree\n</code></pre> <p>Rwf lists are flexible and can contain multiple data types. This separates them from Rust's <code>Vec</code> and slices which can only hold one kind of data.</p> <p>You can also access a specific element in a list by indexing into it with the dot(<code>.</code>) notation:</p> <pre><code>&lt;%= list.1 %&gt;\n</code></pre> <p>Lists are 0-indexed, so the above example accesses the second element in the list.</p>"},{"location":"views/templates/variables/#hashes","title":"Hashes","text":"<p>Hashes, also known as dicts or hash tables, are a key/value storage data type. Unlike a list, it contains a mapping between a value (the key), and a value. Values can be accessed by knowing a key, or by iterating through the entire hash with a for loop:</p> <pre><code>&lt;p&gt;&lt;%= user.name %&gt;&lt;/p&gt;\n&lt;p&gt;&lt;%= user.email %&gt;&lt;/p&gt;\n</code></pre> <p>Rwf hashes use the dot (<code>.</code>) notation to access values in a hash. In this example, the <code>user</code> is a hash, and <code>name</code> and <code>email</code> are keys.</p>"},{"location":"views/templates/variables/#truthy-vs-falsy","title":"Truthy vs. falsy","text":"<p>Variables are often used in if statements to decide whether to execute some code or not. To make the template language less verbose, variables can be evaluated for truthiness without calling explicit functions depending on their data type.</p> <p>The following variables and data types evaluate to false:</p> Data type Value Integer <code>0</code> Float <code>0.0</code> Boolean <code>false</code> String <code>\"\"</code> (empty) List <code>[]</code> (empty) Hash <code>{}</code> (empty) <p>All other variables evaluate to true.</p>"},{"location":"views/templates/variables/#learn-more","title":"Learn more","text":"<ul> <li>If statements</li> <li>For loops</li> <li>Functions</li> </ul>"},{"location":"views/turbo/","title":"Turbo basics","text":""}]}